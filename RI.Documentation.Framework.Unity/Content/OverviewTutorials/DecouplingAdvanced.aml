<?xml version="1.0" encoding="utf-8"?>

<topic id="8ec8f13f-ef95-4aec-8fc1-9b54dff96e01"
       revisionNumber="1">
    <developerConceptualDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5"
                                 xmlns:xlink="http://www.w3.org/1999/xlink">

        <introduction>
            <para>
                A more advanced use of the decoupling features is described in this section.
            </para>
            <alert class="important">
                <para>
                    Please consider reading the remarks section of type and member descriptions as they often contain futher explanations and provide more detailed information.
                </para>
            </alert>
            <autoOutline />
        </introduction>

        <section address="Bootstrapper">
            <title>Bootstrapper</title>
            <content/>
            <sections>
                <section address="Bootstrapper_NoBootstrapper">
                    <title>No Bootstrapper</title>
                    <content>
                        <para>
                            One important thing to know about the bootstrapper is that you do not need the bootstrapper.
                            You can use each decoupling service as its own independent standalone service (e.g. if you only want/need one of them).
                            However, you would have to do all the setup and wiring yourself.
                            Following sections will describe how to use each decoupling service as an independent standalone service.
                        </para>
                    </content>
                </section>
                <section address="Bootstrapper_BootstrapperOptions">
                    <title>Bootstrapper options</title>
                    <content>
                        <para>
                            The bootstrapper provides a few options:
                        </para>
                        <mediaLink>
                            <image xlink:href="BootstrapperOptions" />
                        </mediaLink>
                        <para>
                            These options can be helpful if you do want to use the bootstrapper but not all of the decoupling services or if you want to use your own implementation of a service.
                            The only decoupling service always required by the bootstrapper is the
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionContainer</codeEntityReference>
                            .
                        </para>
                        <para>
                            The available options are:
                        </para>
                        <list class="bullet">
                            <listItem>
                                <para>
                                    <legacyBold>Logging Service</legacyBold>:
                                    Disabled by default.
                                    Creates the logging service (
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Logging.ILogService</codeEntityReference>
                                    , implemented by
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Logging.LogService</codeEntityReference>
                                    ) if enabled.
                                    It is used internally by the framework to create log output and therefore can be used to enable/disable all log output generated by the framework.
                                    It is disabled by default to not spam your logs as especially the
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionContainer</codeEntityReference>
                                    can generate excessive log entries.
                                </para>
                            </listItem>
                            <listItem>
                                <para>
                                    <legacyBold>Module Service</legacyBold>:
                                    Enabled by default.
                                    Creates the modularization service (
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.IModuleService</codeEntityReference>
                                    , implemented by
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.ModuleService</codeEntityReference>
                                    ) if enabled.
                                </para>
                            </listItem>
                            <listItem>
                                <para>
                                    <legacyBold>Module Initialization</legacyBold>:
                                    Enabled by default.
                                    If enabled, the bootstrapper will automatically initialize the modules during the start if an
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.IModuleService</codeEntityReference>
                                    is available.
                                    <codeEntityReference qualifyHint="false">M:RI.Framework.Services.Modularization.IModuleService.Initialize</codeEntityReference>
                                    will be called.
                                </para>
                            </listItem>
                            <listItem>
                                <para>
                                    <legacyBold>Module Unloading</legacyBold>:
                                    Enabled by default.
                                    If enabled, the bootstrapper will automatically unload the modules during the shutdown if an
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.IModuleService</codeEntityReference>
                                    is available.
                                    <codeEntityReference qualifyHint="false">M:RI.Framework.Services.Modularization.IModuleService.Unload</codeEntityReference>
                                    will be called.
                                </para>
                            </listItem>
                            <listItem>
                                <para>
                                    <legacyBold>Dispatcher Service</legacyBold>:
                                    Enabled by default.
                                    Creates the dispatcher service (
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Dispatcher.IDispatcherService</codeEntityReference>
                                    , implemented by
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Dispatcher.DispatcherService</codeEntityReference>
                                    ) if enabled.
                                </para>
                            </listItem>
                            <listItem>
                                <para>
                                    <legacyBold>Scripting Catalog</legacyBold>:
                                    Enabled by default.
                                    Adds a
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Catalogs.ScriptingCatalog</codeEntityReference>
                                    to the
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionContainer</codeEntityReference>
                                    .
                                    The purpose and use of catalogs is described below.
                                </para>
                            </listItem>
                            <listItem>
                                <para>
                                    <legacyBold>Service Locator Binding</legacyBold>:
                                    Enabled by default.
                                    Binds the
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.ServiceLocator</codeEntityReference>
                                    to
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionContainer</codeEntityReference>
                                    if enabled.
                                </para>
                            </listItem>
                        </list>
                    </content>
                </section>
            </sections>
        </section>

        <section address="CompositionContainer">
            <title>CompositionContainer</title>
            <content />
            <sections>
                <section address="CompositionContainer_StandaloneUse">
                    <title>Standalone use</title>
                    <content>
                        <para>
                            You can use a <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionContainer</codeEntityReference> as a standalone service.
                            Just create an instance:
                        </para>
                        <code language="cs">
                            <![CDATA[
using RI.Framework.Composition;


CompositionContainer container = new CompositionContainer();
          ]]>
                        </code>
                        <para>
                            It is also possible to create multiple composition containers.
                            Each composition container will be completely independent of each other and they will share neither exports nor imports.
                        </para>
                    </content>
                </section>
                <section address="CompositionContainer_Catalogs">
                    <title>Catalogs</title>
                    <content>
                        <para>
                            Catalogs are used to tell a <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionContainer</codeEntityReference> where to look for exports.
                            Only exports found in catalogs, which are added to the composition container, will be discovered and used.
                            Catalogs are added using <codeEntityReference qualifyHint="false">M:RI.Framework.Composition.CompositionContainer.AddCatalog</codeEntityReference> and removed using <codeEntityReference qualifyHint="false">M:RI.Framework.Composition.CompositionContainer.RemoveCatalog</codeEntityReference>.
                            Multiple different catalogs can be used at the same time.
                        </para>
                        <para>
                            Catalogs can be added and removed dynamically, as shown above.
                            When the available catalogs change, the available exports in the corresponding <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionContainer</codeEntityReference> will be updated as well, adding or removing exports dynamically.
                        </para>
                        <para>
                            All catalogs inherit from <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionCatalog</codeEntityReference>.
                            You can use one or more of the built-in catalogs and/or implement your own.
                        </para>
                        <para>
                            The following built-in catalogs exist:
                        </para>
                        <list class="bullet">
                            <listItem>
                                <para>
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Catalogs.ScriptingCatalog</codeEntityReference>:
                                    All exported types of the Unity scripting assemblies are used for discovery.
                                    Unity scripting assemblies are all assemblies which start with the name <legacyItalic>Assembly-CSharp</legacyItalic>.
                                    Therefore, this catalog makes possible the &quot;magic&quot; discovery of all the types you add to your Unity project.
                                    This catalog is added by default by the <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Bootstrapper</codeEntityReference>.
                                </para>
                            </listItem>
                            <listItem>
                                <para>
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Catalogs.AssemblyCatalog</codeEntityReference>:
                                    All exported types of one or more specified assemblies are used for discovery.
                                </para>
                            </listItem>
                            <listItem>
                                <para>
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Catalogs.DirectoryCatalog</codeEntityReference>:
                                    All managed DLL assembly files in a specified directory will be loaded and their exported types used for discovery.
                                </para>
                            </listItem>
                            <listItem>
                                <para>
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Catalogs.FileCatalog</codeEntityReference>:
                                    All exported types of a specified managed DLL assembly file are used for discovery.
                                </para>
                            </listItem>
                            <listItem>
                                <para>
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Catalogs.TypeCatalog</codeEntityReference>:
                                    A catalog where one or more exports can be added manually by directly specifying the type.
                                </para>
                            </listItem>
                            <listItem>
                                <para>
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Catalogs.InstanceCatalog</codeEntityReference>:
                                    A catalog where one or more exports can be added manually by directly specifying the instances.
                                </para>
                            </listItem>
                            <listItem>
                                <para>
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Catalogs.AppDomainCatalog</codeEntityReference>:
                                    All exported types of all assemblies loaded into the current application domain will be used for discovery.
                                </para>
                            </listItem>
                        </list>
                    </content>
                </section>
                <section address="CompositionContainer_Recomposition">
                    <title>Recomposition</title>
                    <content>
                        <para>
                            By default, all imports (<codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Model.ImportAttribute</codeEntityReference>) are recomposable.
                            This means that when the available exports of a <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionContainer</codeEntityReference> is changed (e.g. by adding or removing a catalog), the imports are updated automatically.
                        </para>
                        <para>
                            If a type implements <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Model.IImporting</codeEntityReference>, it is notified when one or more of its imports have been updated.
                            The following example shows how to track recompositions:
                        </para>
                        <code language="cs">
                            <![CDATA[
using RI.Framework.Composition.Model;
using RI.Framework.Services.Modularization;


[Export]
public interface IEnemyAI
{
}


[Export]
public class EnemyManager : MonoModule, IImporting
{
    [Import]
    public Import ImportedAIs { get; set; }

    public IEnemyAI[] UsedAIs;
  
    public void ImportsResolving (CompositionFlags composition, bool updated)
    {
        // called immediately before imports are resolved
    }
  
    public void ImportsResolved (CompositionFlags composition, bool updated)
    {
        // called immediately after imports were resolved
        
        if(updated)
        {
            this.UsedAIs = this.ImportedAIs.ToArray<IEnemyAI>();
        }
    }
}
          ]]>
                        </code>
                    </content>
                </section>
                <section address="CompositionContainer_NamedExportsAndImports">
                    <title>Named exports and imports</title>
                    <content>
                        <para>
                            So far, we have seen how to identify exports and imports using their types.
                            Besides that, it is also possible to identify them using names.
                            The following example shows how to use names instead of types:
                        </para>
                        <code language="cs">
                            <![CDATA[
using RI.Framework.Composition.Model;
using RI.Framework.Services.Modularization;


[Export("MyRules")]
public class GameRules : MonoModule
{
}


[Export]
public class EnemyManager : MonoModule
{
    [Import("MyRules")]
    public GameRules Rules { get; set; }
}
          ]]>
                        </code>
                    </content>
                </section>
                <section address="CompositionContainer_MultiExport">
                    <title>Multi-export</title>
                    <content>
                        <para>
                            The same type or instance can also be exported multiple times under different names or even types:
                        </para>
                        <code language="cs">
                            <![CDATA[
using RI.Framework.Composition.Model;
using RI.Framework.Services.Modularization;


public interface IGameRules
{
}


[Export] // default export (GameRules)
[Export("MyRules")] // named export (MyRules)
[Export(typeof(IGameRules))] // export as different type (IGameRules)
public class GameRules : MonoModule, IGameRules
{
}


[Export]
public class EnemyManager : MonoModule
{
    // all of the following imports will get the same instance of the GameRules type

    [Import]
    public GameRules Rules { get; set; }
    
    [Import("MyRules")]
    public GameRules Rules { get; set; }
    
    [Import(typeof(IGameRules))]
    public GameRules Rules { get; set; }
}
          ]]>
                        </code>
                    </content>
                </section>
                <section address="CompositionContainer_PrepareForModsPlugins">
                    <title>Prepare for Mods/Plugins</title>
                    <content>
                        <para>
                            The <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionContainer</codeEntityReference> can be used to prepare your architecture for easy integration of mods or plugins.
                            As shown in the examples above, catalogs can be added and removed dynamically and doing so will update the affected imports.
                            We can use this to implement a mod/plugin infrastructure.
                        </para>
                        <para>
                            The following example shows a simple mod infrastructure.
                            It is assumed that each mod is in its own directory.
                            We load all DLLs of each mod which will also automatically load and initialize all of the mods modules.
                            We could then use the module initialization to load further resources for each mod, as necessary (e.g. meshes, sounds, etc.).
                            The example particularly shows how a mod can add new enemy AI behaviour in a very simple way.
                        </para>
                        <code language="cs">
                            <![CDATA[
using System;
using System.Collections.Generic;
using RI.Framework.Composition;
using RI.Framework.Composition.Catalogs;
using RI.Framework.Composition.Model;
using RI.Framework.Services;
using RI.Framework.Services.Modularization;
using RI.Framework.IO.Paths;
using RI.Framework.Collections;


// in your main Unity project:


public class ModInfo
{
    // this class holds information about one mod

    public DirectoryPath ModDir;
    public DirectoryCatalog Catalog;

    public ModInfo (DirectoryPath modDir)
    {
        this.ModDir = modDir;
        this.Catalog = new DirectoryCatalog(modDir);
    }

    public void Load()
    {
        // to load a mod, we just add its catalog to the composition container, it will do the rest

        ServiceLocator.GetInstance<CompositionContainer> ().AddCatalog (this.Catalog);
    }

    public void Unload()
    {
        // to unload a mod, we remove the catalog

        ServiceLocator.GetInstance<CompositionContainer> ().RemoveCatalog (this.Catalog);
    }
}


[Export]
public class ModManager : MonoModule
{
    // this is our mod manager

    public List<ModInfo> AvailableMods { get; set; }

    protected override void Initialize ()
    {
        base.Initialize ();

        this.AvailableMods = new List<ModInfo> ();

        // get the path to our mod root directory where each mod is in its own subdirectory
        DirectoryPath modRoot = new DirectoryPath ("path to mod directory");

        // get each subdirectory and create the mod objects
        List<DirectoryPath> modDirs = modRoot.GetSubdirectories (false, false);
        foreach (string modDir in modDirs)
        {
            // create the mod object...
            ModInfo mod = new ModInfo (modDir);
            this.AvailableMods.Add (mod);

            // ...and load the mod
            mod.Load ();
        }
    }
}


[Export]
public interface IEnemyAI
{
    // this is the interface which our mod is going to implement
    // note that you need to reference Assembly-CSharp.dll from your mod

    // for the sake of simplicity, we keep the interface empty
}


[Export]
public class EnemyManager : MonoModule, IImporting
{
    // this is our enemy manager
    // you could, for example, pick a random AI from UsedAIs each time a new enemy is spawned

    [ImportProperty(typeof(IEnemyAI))]
    private Import ImportedAIs  { get; set; }

    private IEnemyAI[] UsedAIs;

    public void ImportsResolved (CompositionFlags composition, bool updated)
    {
        if (updated)
        {
            // each time the imported AIs were updated, we get and keep the array of AIs
            this.UsedAIs = this.ImportedAIs.ToArray<IEnemyAI> ();
        }
    }

    public void ImportsResolving (CompositionFlags composition)
    {
    }
    
    public void SpawnEnemy ()
    {
        // ...
        
        IEnemyAI ai = this.UsedAIs.PopRandom(new Random());
        
        // ...
    }
}


// in some mods DLL:


public class MyEnemyAI : IEnemyAI
{
    // this is our small little mod, a custom enemy AI
}

public class MyModModule : MonoModule
{
    // this is our mods main module which is used to load/unload additional resources

    protected override void Initialize ()
    {
        base.Initialize ();

        // load resources of this mod (meshes, sounds, ...)

        // good to know: as soon as the module is loaded...
        // ...its catalog is added...
        // ...which adds this module as an export...
        // ...which is detected by the module service...
        // ...which then initializes the module if (and only if!) the modules were already initialized using IModuleService.Initialize
    }

    protected override void Unload ()
    {
        base.Unload ();

        // unload resources of this mod

        // good to know: as soon as the mod is unloaded...
        // ...its catalog is removed...
        // ...which removes this module as an export...
        // ...which is detected by the module service...
        // ...which then unloads the module, even if the game continues to run
    }
}
                            ]]>
                        </code>
                    </content>
                </section>
            </sections>
        </section>

        <section address="IModuleService">
            <title>IModuleService</title>
            <content/>
            <sections>
                <section address="IModuleService_Interface">
                    <title>Interface</title>
                    <content>
                        <para>
                             The module service is always represented by the interface <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.IModuleService</codeEntityReference> and not its default implementation, <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.ModuleService</codeEntityReference>.
                             <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.ModuleService</codeEntityReference> does not have an <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Model.ExportAttribute</codeEntityReference> so only <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.IModuleService</codeEntityReference> can be used with <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionContainer</codeEntityReference> or <codeEntityReference qualifyHint="false">T:RI.Framework.Services.ServiceLocator</codeEntityReference> (unless explicitly added).
                             This decouples the module service itself and allows you to substitute it with your own implementation.
                        </para>
                    </content>
                </section>
                <section address="IModuleService_StandaloneUse">
                    <title>Standalone use</title>
                    <content>
                        <para>
                            You can use the default module service implementation <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.ModuleService</codeEntityReference> as a standalone service.
                            Just create an instance:
                        </para>
                        <code language="cs">
                            <![CDATA[
using RI.Framework.Services.Modularization;


IModuleService moduleService = new ModuleService();
                            ]]>
                        </code>
                        <para>
                            It is also possible to create multiple independent instances of <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.ModuleService</codeEntityReference>.
                        </para>
                    </content>
                </section>
                <section address="IModuleService_DependencyOnCompositionContainer">
                    <title>Dependency on CompositionContainer</title>
                    <content>
                        <para>
                            The default module service implementation <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.ModuleService</codeEntityReference> has an import property to import all implementations of <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.IModule</codeEntityReference>.
                            It also implements <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Model.IImporting</codeEntityReference>, making it aware when the imported <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.IModule</codeEntityReference>s were updated/recomposed.
                            Therefore, it is not necessary to add the modules explicitly as they are automatically discovered by the <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionManager</codeEntityReference> and imported by <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.ModuleService</codeEntityReference>.
                            However, if <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.ModuleService</codeEntityReference> is not contained in a <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionContainer</codeEntityReference>, the modules must be manually added and removed using <codeEntityReference qualifyHint="false">M:RI.Framework.Services.Modularization.ModuleService.AddModule</codeEntityReference> and <codeEntityReference qualifyHint="false">M:RI.Framework.Services.Modularization.ModuleService.RemoveModule</codeEntityReference>.
                            It is possible to use both importing and explicit add/remove but you cannot explicitly remove a module which is imported.
                        </para>
                    </content>
                </section>
                <section address="IModuleService_ModuleImplementation">
                    <title>Module implementation</title>
                    <content>
                        <para>
                            There are two base implementations for modules which implement <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.IModule</codeEntityReference>: <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.MonoModule</codeEntityReference> and <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.Module</codeEntityReference>.
                            You can use one of these base classes to implement your modules or implement <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.IModule</codeEntityReference> directly.
                        </para>
                        <para>
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.MonoModule</codeEntityReference> is used for modules which also need to be a <legacyItalic>MonoBehaviour</legacyItalic>.
                            When such modules are instantiated, a <legacyItalic>GameObject</legacyItalic> is automatically created to which the module instance is attached (one <legacyItalic>GameObject</legacyItalic> per module).
                        </para>
                        <para>
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.Module</codeEntityReference> is used for modules which do not require to be a <legacyItalic>MonoBehaviour</legacyItalic>.
                        </para>
                    </content>
                </section>
                <section address="IModuleService_InitializationAndUnloading">
                    <title>Initialization and unloading</title>
                    <content>
                        <para>
                            The initialization and unlaoding of modules should be managed by the module service.
                            Do not call <codeEntityReference qualifyHint="false">M:RI.Framework.Services.Modularization.IModule.Initialize</codeEntityReference> or <codeEntityReference qualifyHint="false">M:RI.Framework.Services.Modularization.IModule.Unload</codeEntityReference> on a module directly.
                        </para>
                        <para>
                            The module service knows whether a module is initialized or not through its <codeEntityReference qualifyHint="false">P:RI.Framework.Services.Modularization.IModule.IsInitialized</codeEntityReference> property.
                            At a certain point during startup, the modules are going to be initialized (e.g. when the bootstrapper calls <codeEntityReference qualifyHint="false">M:RI.Framework.Services.Modularization.IModuleService.Initialize</codeEntityReference>).
                            This will initialize all modules which are known to the module service at this point in time.
                            If a module is added later, the added module is also initialized immediately after it was added.
                        </para>
                        <para>
                            The same applies for unloading in a somewhat reversed fashion:
                            At a certain point during shutdown, the modules are going to be unloaded (e.g. when the bootstrapper calls <codeEntityReference qualifyHint="false">M:RI.Framework.Services.Modularization.IModuleService.Unload</codeEntityReference>).
                            This will unload all modules which are known to the module service at this point in time.
                            If a module was removed earlier, the removed module was already unloaded during removal.
                        </para>
                        <para>
                            This mechanism ensures that modules are always properly initialized and unloaded, regardless when they were added/removed.
                        </para>
                    </content>
                </section>
            </sections>
        </section>

        <section address="IDispatcherService">
            <title>IDispatcherService</title>
            <content>
                <para>
                    Only interface
                    Independent
                    IDispatcherOperation
                </para>
            </content>
            <sections>
            <sections>
                <section address="IDispatcherService_Interface">
                    <title>Interface</title>
                    <content>
                        <para>
                             The dispatcher service is always represented by the interface <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Dispatcher.IDispatcherService</codeEntityReference> and not its default implementation, <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Dispatcher.DispatcherService</codeEntityReference>.
                             <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Dispatcher.DispatcherService</codeEntityReference> does not have an <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Model.ExportAttribute</codeEntityReference> so only <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Dispatcher.IDispatcherService</codeEntityReference> can be used with <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionContainer</codeEntityReference> or <codeEntityReference qualifyHint="false">T:RI.Framework.Services.ServiceLocator</codeEntityReference> (unless explicitly added).
                             This decouples the dispatcher service itself and allows you to substitute it with your own implementation.
                        </para>
                    </content>
                </section>
                <section address="IDispatcherService_StandaloneUse">
                    <title>Standalone use</title>
                    <content>
                        <para>
                            You can use the default dispatcher service implementation <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Dispatcher.DispatcherService</codeEntityReference> as a standalone service.
                            Just create an instance:
                        </para>
                        <code language="cs">
                            <![CDATA[
using RI.Framework.Services.Modularization;


IDispatcherService dispatcher = new DispatcherService();
                            ]]>
                        </code>
                        <para>
                            It is also possible to create multiple independent instances of <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Dispatcher.DispatcherService</codeEntityReference>.
                        </para>
                    </content>
                </section>
                <section address="IDispatcherService_DispatcherOperation">
                    <title>IDispatcherOperation</title>
                    <content>
                        <para>
                            When a message is broadcasted or an operation is dispatched, the dispatcher service returns an <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Dispatcher.IDispatcherOperation</codeEntityReference>.
                            This object provides some advanced control over the broadcast of messages or execution of operations respectively.
                            Each broadcast and each dispatch will return its own unique <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Dispatcher.IDispatcherOperation</codeEntityReference>.
                        </para>
                        <para>
                            You can cancel a broadcast or execution:
                        </para>
                        <para>
                            You can reschedule a broadcast or execution so that it is delayed for a specified amount of time or until a specified point in time:
                        </para>
                        <para>
                            You can set a timeout (helpful for lower priorities which do not guarantee execution):
                        </para>
                        <para>
                            You can set a callback:
                        </para>
                        <para>
                            You can chain all these methods fluently:
                        </para>
                        <para>
                            You can check the current execution status:
                        </para>
                        <para>
                            You can get the return value of a dispatched method:
                        </para>
                        <para>
                            Note that for broadcasts and dispatchs of priority <legacyItalic>Now</legacyItalic>, the returned <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Dispatcher.IDispatcherOperation</codeEntityReference> is only useful for getting the results of dispatched methods because the the operation will already be completed when the <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Dispatcher.IDispatcherOperation</codeEntityReference> is returned.
                        </para>
                    </content>
                </section>
            </sections>
        </section>

        <relatedTopics />

    </developerConceptualDocument>
</topic>
