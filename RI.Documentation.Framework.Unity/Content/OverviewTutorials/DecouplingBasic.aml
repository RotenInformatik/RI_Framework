<?xml version="1.0" encoding="utf-8"?>

<topic id="3120b15f-18f6-4b5e-92c7-8b51e2bedfb1"
       revisionNumber="1">
    <developerConceptualDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5"
                                 xmlns:xlink="http://www.w3.org/1999/xlink">

        <introduction>
            <para>
                A simple and straigh-forward use of the decoupling features is described in this section.
            </para>
            <alert class="important">
                <para>
                    Please consider reading the remarks section of type and member descriptions as they often contain futher explanations and provide more detailed information.
                </para>
            </alert>
            <autoOutline />
        </introduction>

        <section address="Bootstrapper">
            <title>Bootstrapper</title>
            <content>
                <para>
                    A
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Bootstrapper</codeEntityReference>
                    is used to load all the actual decoupling services during scene load (using Unitys
                    <legacyItalic>Awake()</legacyItalic> ).
                </para>
                <para>
                    Note that the bootstrapper is only required once as it is persistent over all scenes (using Unitys
                    <legacyItalic>DontDestroyOnLoad()</legacyItalic> ).
                </para>
                <para>
                    The bootstrapper is added to a <legacyItalic>GameObject</legacyItalic> in a scene using drag-and-drop from
                    <legacyItalic>RI.Framework.Unity.dll</legacyItalic>:
                </para>
                <mediaLink>
                    <image xlink:href="BootstrapperDragDrop" />
                </mediaLink>
                <para>
                    Alternatively, it can also be done in code by adding
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Bootstrapper</codeEntityReference>
                    as a component to a <legacyItalic>GameObject</legacyItalic>:
                </para>
                <code language="cs">
                    <![CDATA[
GameObject go = new GameObject();
go.AddComponent<Bootstrapper>();
          ]]>
                </code>
                <para>
                    After the scene load, the bootstrapper can be seen in the list of objects:
                </para>
                <mediaLink>
                    <image xlink:href="BootstrapperObject" />
                </mediaLink>
            </content>
        </section>

        <section address="IModuleService">
            <title>IModuleService</title>
            <content>
                <para>
                    An implementation of
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.IModuleService</codeEntityReference>
                    is used to implement and manage modules.
                    Modules are very similar to singletons as they are started once and then used throughout the game.
                    Typical examples for modules are &quot;Controllers&quot; or &quot;Managers&quot; (e.g. PlayerController, EnemyManager, etc.) or globally available services and functionality in general.
                </para>
                <para>
                    The default implementation of
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.IModuleService</codeEntityReference>
                    is
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.ModuleService</codeEntityReference>
                    .
                </para>
                <para>
                    To implement a module, simply add a class to your project which inherits from
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.MonoModule</codeEntityReference>
                    :
                </para>
                <code language="cs">
                    <![CDATA[
using RI.Framework.Services;
using RI.Framework.Services.Modularization;


public class EnemyManager : MonoModule
{
    protected override void Initialize ()
    {
        base.Initialize();
        
        // called when the module is initialized (e.g. when the bootstrapper starts)
    }
  
    protected override void Unload ()
    {
        base.Unload();
    
        // called when the module is unloaded (e.g. when the game ends)
    }
}
          ]]>
                </code>
                <para>
                    The bootstrapper will create the module service which in turn will discover, instantiate, and initialize all modules (using a composition container as described in the next section).
                </para>
                <para>
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.MonoModule</codeEntityReference>
                    inherits from <legacyItalic>MonoBehaviour</legacyItalic> so a module can use all Unity features as usual.
                    A <legacyItalic>GameObject</legacyItalic> is created for each module automatically.
                </para>
                <para>
                    The advantage of using modules instead of regular <legacyItalic>MonoBehaviour</legacyItalic>s attached to
                    <legacyItalic>GameObject</legacyItalic>s will be shown in the next section.
                </para>
            </content>
        </section>

        <section address="CompositionContainer">
            <title>CompositionContainer</title>
            <content>
                <para>
                    A
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionContainer</codeEntityReference>
                    provides Dependency Injection (DI) and Inversion-of-Control (IoC).
                </para>
                <para>
                    DI and IoC are powerful concepts: You just declare the dependency you need and it will be resolved and assigned for you.
                    This includes instance creation, singleton management, and cascading dependencies.
                </para>
                <para>
                    To add a dependency to a module:
                </para>
                <code language="cs">
                    <![CDATA[
using RI.Framework.Composition;
using RI.Framework.Composition.Model;
using RI.Framework.Services;
using RI.Framework.Services.Modularization;


[Export]
public class GameRules : MonoModule
{
}


[Export]
public class EnemyManager : MonoModule
{
    [Import]
    public GameRules Rules { get; set; }
  
    // EnemyManager has a dependency to GameRules which will be automatically resolved and assigned
    // the Rules property can be used everywhere inside EnemyManager, except its constructor
}
          ]]>
                </code>
                <para>
                    The bootstrapper will create the composition container which then discovers all types it can use for importing.
                    A type can be used for importing (as declared by
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Model.ImportAttribute</codeEntityReference>
                    ) if it is exported.
                    To export a type, and therefore make it discoverable by the composition container, add an
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Model.ExportAttribute</codeEntityReference>
                    to the type.
                </para>
                <para>
                    An object will have its imports resolved when the object is known by the composition container (means: its type is exported) and instances for that object/type are retrieved using the composition container (e.g. using importing).
                    This means that each object which is imported has its own imports resolved, and the imports of those imports, and so on.
                    Alternative perspective: Each exported type gets its imports resolved if instances of those exported types are retrieved using the composition container.
                </para>
                <para>
                    Besides importing, an instance of a type can also be explicitly retrieved from a composition container (note that the composition container contains itself):
                </para>
                <code language="cs">
                    <![CDATA[
using RI.Framework.Composition;
using RI.Framework.Composition.Model;
using RI.Framework.Services;
using RI.Framework.Services.Modularization;


[Export]
public class GameRules : MonoModule
{
}


[Export]
public class EnemyManager : MonoModule
{
    [Import]
    public CompositionContainer Container { get; set; }

    protected override void Initialize ()
    {
        base.Initialize();
        
        GameRules rules = this.Container.GetExport<GameRules>();
        // do something with rules
    }
}
          ]]>
                </code>
                <para>
                    If you want to export a type which is not under your control, so you cannot apply
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Model.ExportAttribute</codeEntityReference>
                    to it, you can also explicitly export a type:
                </para>
                <code language="cs">
                    <![CDATA[
using RI.Framework.Composition;
using RI.Framework.Composition.Model;
using RI.Framework.Services;
using RI.Framework.Services.Modularization;


[Export]
public class EnemyManager : MonoModule
{
    [Import]
    public CompositionContainer Container { get; set; }

    protected override void Initialize ()
    {
        base.Initialize();
        
        this.Container.AddExport(typeof(SomeOtherType), typeof(SomeOtherType), false);
    }
}
          ]]>
                </code>
                <para>
                    And if you want to export an already created instance instead of a type (for example when constructing the object is complex), you can also explicitly export an object:
                </para>
                <code language="cs">
                    <![CDATA[
using RI.Framework.Composition;
using RI.Framework.Composition.Model;
using RI.Framework.Services;
using RI.Framework.Services.Modularization;


[Export]
public class EnemyManager : MonoModule
{
    [Import]
    public CompositionContainer Container { get; set; }

    protected override void Initialize ()
    {
        base.Initialize();
        
        this.Container.AddExport(new SomeOtherType("Test", 123, SomeEnum.Default), typeof(SomeOtherType));
    }
}
          ]]>
                </code>
                <para>
                    As shown, exporting and importing is not restricted to modules.
                    In fact, any class type can be exported and/or have imports as long as they go through the composition container.
                    One special case is a type which inherits from <legacyItalic>MonoBehaviour</legacyItalic>.
                    Instances of <legacyItalic>MonoBehaviour</legacyItalic> cannot be instantiated in a normal way, they need to be added as a component to a
                    <legacyItalic>GameObject</legacyItalic>.
                    Therefore, if you want to make a <legacyItalic>MonoBehaviour</legacyItalic> discoverable, you need to inherit from
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.ComposableMonoBehaviour</codeEntityReference>
                    instead of <legacyItalic>MonoBehaviour</legacyItalic>.
                    During instantiation, a new <legacyItalic>GameObject</legacyItalic> is automatically created to which the
                    <legacyItalic>MonoBehaviour</legacyItalic> is then added.
                </para>
                <code language="cs">
                    <![CDATA[
using RI.Framework.Composition;
using RI.Framework.Composition.Model;
using RI.Framework.Services;
using RI.Framework.Services.Modularization;


[Export]
public class Raycaster : ComposableMonoBehaviour
{
    // this class is only instantiated when an instance of it is requested through the composition container (import or explicit)
}


[Export]
public class EnemyManager : MonoModule
{
    protected override void Initialize ()
    {
        base.Initialize();
        
        Raycaster raycaster = this.Container.GetExport<Raycaster>();
        // do something with raycaster
    }
}
          ]]>
                </code>
                <para>
                    It is also possible to import multiple instances of a type.
                    The following example shows how to import all concrete implementations of an interface:
                </para>
                <code language="cs">
                    <![CDATA[
using RI.Framework.Composition;
using RI.Framework.Composition.Model;
using RI.Framework.Services;
using RI.Framework.Services.Modularization;


[Export]
public interface IEnemyAI
{
}


public class SmartEnemyAI : IEnemyAI
{
}


public class DumbEnemyAI : IEnemyAI
{
}


[Export]
public class EnemyManager : MonoModule
{
    // importing multiple instances is only possible with the Import proxy because we would otherwise have a dependency on System.Reflection.Emit
    // this is also why we need to explicitly specify the desired type
    [Import(typeof(IEnemyAI))]
    public Import AIs { get; set; }
  
    protected override void Initialize ()
    {
        base.Initialize();
        
        // one way is to retrieve all instances as an array
        IEnemyAI[] aiArray = this.AIs.ToArray<IEnemyAI>();
        
        // ...or a list
        List<IEnemyAI> aiList = this.AIs.ToList<IEnemyAI>();
        
        // ...or by enumerating them
        foreach(var ai in this.AIs.Values<IEnemyAI>())
        {
        }
        
        // ...or by picking the first available
        IEnemyAI first = this.AIs.Value<IEnemyAI>();
    }
}
          ]]>
                </code>
                <para>
                    This allows you to maximize decoupling: You just use an interface, resulting in zero dependency to the actually used type.
                    The used type (or types) is not known to the using type as even for instantiation the required interface is requested instead of an actual type.
                </para>
                <para>
                    What was not answered yet: Why use modules instead of regular
                    <legacyItalic>MonoBehaviour</legacyItalic>s attached to <legacyItalic>GameObjects</legacyItalic>s?
                    The three reasons are: Modules are singletons, go through the composition container (making them exportable/importable), and are automatically instantiated by the module service during bootstrapping (compared to other exported types which are only instantiated when retrieved from the composition container; possibly never if an instance is never requested).
                </para>
            </content>
        </section>

        <section address="ServiceLocator">
            <title>ServiceLocator</title>
            <content>
                <para>
                    The
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.ServiceLocator</codeEntityReference>
                    lets you use the decoupling features from anywhere.
                    It provides global access to the composition container which is created by the bootstrapper.
                </para>
                <para>
                    To use the service locator, simply specify the type you need an instance of (similar to explicitly retrieving an instance from a composition container):
                </para>
                <code language="cs">
                    <![CDATA[
ServiceLocator.GetInstance<GameManager>().Win();
          ]]>
                </code>
                <para>
                    This works also for multiple instances of a type:
                </para>
                <code language="cs">
                    <![CDATA[
using RI.Framework.Composition;
using RI.Framework.Composition.Model;
using RI.Framework.Services;
using RI.Framework.Services.Modularization;


[Export]
public interface IEnemyAI
{
}


public class SmartEnemyAI : IEnemyAI
{
}


public class DumbEnemyAI : IEnemyAI
{
}


[Export]
public class EnemyManager : MonoModule
{
    public IEnemyAI[] EnemyAIs;
  
    protected override void Initialize ()
    {
        base.Initialize();
        
        this.EnemyAIs = ServiceLocator.GetInstances<IEnemyAI>();
    }
}
          ]]>
                </code>
                <para>
                    Be aware that using the service locator is considerably slower than property-based importing as shown in the previous section.
                    Property-based importing performs resolving of the instances only once (which is not fully true, as explained in
                    <link xlink:href="8ec8f13f-ef95-4aec-8fc1-9b54dff96e01" />).
                    The service locator however performs resolving each time it is used.
                </para>
            </content>
        </section>

        <section address="IDispatcherService_Messaging">
            <title>IDispatcherService (Messaging)</title>
            <content>
                <para>
                    An implementation of
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Dispatcher.IDispatcherService</codeEntityReference>
                    is used to send and receive messages.
                    Sending and receiving messages is very simple: Any object which has access to
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Dispatcher.IDispatcherService</codeEntityReference>
                    (e.g. by using property-based importing or through the service locator) can send and receive messages.
                </para>
                <para>
                    The default implementation of
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Dispatcher.IDispatcherService</codeEntityReference>
                    is
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Dispatcher.DispatcherService</codeEntityReference>
                    .
                </para>
                <para>
                    To receive a message of a specified type, a receiver needs to be registered:
                </para>
                <code language="cs">
                    <![CDATA[
using RI.Framework.Services;
using RI.Framework.Services.Dispatcher;
using RI.Framework.Services.Modularization;


public class KillEvent
{
}


public class GameRules : MonoModule
{
    [Import]
    public IDispatcherService Dispatcher { get; set; }
  
    private void OnKill(KillEvent killEvent)
    {
        // process kill event
    }

    protected override void Initialize ()
    {
        base.Initialize();
        
        this.Dispatcher.RegisterReceiver<KillEvent>(this.OnKill);
    }
}
          ]]>
                </code>
                <para>
                    A message is sent by broadcasting it to all its registered receivers:
                </para>
                <code language="cs">
                    <![CDATA[
using RI.Framework.Services;
using RI.Framework.Services.Dispatcher;
using RI.Framework.Services.Modularization;


public class KillEvent
{
}


public class EnemyManager : MonoModule
{
    [Import]
    public IDispatcherService Dispatcher { get; set; }

    void Update ()
    {
        if(enemyIsKilled)
        {
            this.Dispatcher.Broadcast(new KillEvent());
        }
    }
}
          ]]>
                </code>
                <para>
                    The messaging system is type-based.
                    It means that a message of a certain type is received by each receiver which registered for the messages type.
                    Any class type objects can be sent/received.
                </para>
                <para>
                    Messages can be sent from any thread but are delivered to the receivers in Unitys main/foreground thread.
                    This makes it a good tool for asynchronous cross-thread interaction or, for example, to deliver results from a background thread to the main/foreground thread.
                </para>
                <para>
                    Messages are delivered asynchronously.
                    It means that the messages are not immediately delivered to the respective receivers when sent.
                    Instead, the messages are put into a queue and delivered from there during certain points in time of a frame cycle.
                    The only exception to this is when the priority <legacyItalic>Now</legacyItalic> is used, which will deliver the message immediately.
                </para>
                <para>
                    Each message has a
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Dispatcher.DispatcherPriority</codeEntityReference>
                    which defines at which point in time during a frame cycle the message is delivered.
                </para>
            </content>
        </section>

        <section address="IDispatcherService_Jobs">
            <title>IDispatcherService (Jobs)</title>
            <content>
                <para>
                    Besides messaging, an implementation of
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Dispatcher.IDispatcherService</codeEntityReference>
                    also lets you dispatch operations (or jobs).
                </para>
                <para>
                    Note that there is also
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Utilities.Threading.ThreadMover</codeEntityReference>
                    which is a nice cross-thread execution tool when working with coroutines.
                </para>
                <para>
                    The following example shows how to dispatch a simple operation:
                </para>
                <code language="cs">
                    <![CDATA[
using RI.Framework.Services;
using RI.Framework.Services.Dispatcher;
using RI.Framework.Services.Modularization;


public class MyModule : MonoModule
{
    [Import]
    public IDispatcherService Dispatcher { get; set; }

    protected override void Initialize ()
    {
        base.Initialize();
        
        this.Dispatcher.Dispatch(() => Debug.Log("I'm being logged with default priority"));
    
        this.Dispatcher.Dispatch(DispatcherPriority.Idle, () => Debug.Log("I'm being logged when the dispatcher is idle"));
    }
}
          ]]>
                </code>
                <para>
                    The following example shows how to dispatch an operation which has parameters:
                </para>
                <code language="cs">
                    <![CDATA[
using RI.Framework.Services;
using RI.Framework.Services.Dispatcher;
using RI.Framework.Services.Modularization;


public class MyModule : MonoModule
{
    [Import]
    public IDispatcherService Dispatcher { get; set; }

    protected override void Initialize ()
    {
        base.Initialize();
        
        this.Dispatcher.Dispatch(x => Debug.Log(x), "I'm x !");

        this.Dispatcher.Dispatch(DispatcherPriority.Background, filename => 
        {
            LoadMeshFromFile(filename);
        }, "Spaceship.obj");
    }
}
          ]]>
                </code>
                <para>
                    Operations can be dispatched from any thread but are executed in Unitys main/foreground thread.
                    This makes it a good tool for asynchronous cross-thread execution or, for example, to continue a procedure from a background thread in the main/foreground thread.
                </para>
                <para>
                    Operations are executed asynchronously.
                    It means that the operations are not immediately executed when dispatched.
                    Instead, the operations are put into a queue and executed from there during certain points in time of a frame cycle.
                    The only exception to this is when the priority <legacyItalic>Now</legacyItalic> is used, which will execute the operation immediately.
                </para>
                <para>
                    Each operation has a
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Dispatcher.DispatcherPriority</codeEntityReference>
                    which defines at which point in time during a frame cycle the operation is executed.
                </para>
                <para>
                    A particular use case for dispatched operations are situations where run-to-completion behaviour is required.
                    For example: A method needs an operation executed but not before the method itself has returned.
                    This is especially required for handling state transitions in state machines where you want to dispatch a state transition but the actual transition should not happen before the current method is finished (so that the rest of the method, after the dispatching, can still finish with the current state).
                </para>
            </content>
        </section>

        <relatedTopics />

    </developerConceptualDocument>
</topic>
