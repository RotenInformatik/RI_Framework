<?xml version="1.0" encoding="utf-8"?>

<topic id="3120b15f-18f6-4b5e-92c7-8b51e2bedfb1"
			 revisionNumber="1">
	<developerConceptualDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5"
															 xmlns:xlink="http://www.w3.org/1999/xlink">

		<introduction>
			<para>
				A simple and straigh-forward use of the decoupling features is described in this section.
			</para>
			<alert class="important">
				<para>
					Please consider reading the remarks section of type and member descriptions as they often contain futher explanations and provide more detailed information.
				</para>
			</alert>
			<autoOutline/>
		</introduction>

		<section address="Bootstrapper">
			<title>Bootstrapper</title>
			<content>
				<para>
					A <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Bootstrapper</codeEntityReference> is used to load all the actual decoupling services during scene load (using Unitys Awake() ).
				</para>
				<para>
					Note that the bootstrapper is only required once as it is persistent over all scenes (using Unitys DontDestroyOnLoad() ).
				</para>
				<para>
					Add a new GameObject to the scene and then add the bootstrapper via drag-and-drop from the <legacyItalic>RI.Framework.Unity.dll</legacyItalic>:
				</para>
				<para>
					[screenshot: drag and drop]
				</para>
				<para>
					Alternatively, you can also do this in code by adding <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Bootstrapper</codeEntityReference> as a component to a GameObject:
				</para>
				<code language="cs">
					[code: add bootstrapper in code]
				</code>
				<para>
					When you now start the scene, you can see the bootstrapper object:
				</para>
				<para>
					[screenshot: bootstrapper object]
				</para>
			</content>
		</section>

		<section address="IModuleService">
			<title>IModuleService</title>
			<content>
				<para>
					An implementation of <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.IModuleService</codeEntityReference> is used to implement and manage modules.
					Modules are very similar to singletons as they are started once and then used throughout the game.
					Typical examples for modules are &quot;Controllers&quot; or &quot;Managers&quot; (e.g. PlayerController, EnemyManager, etc.) or globally available services and functionality in general.
				</para>
				<para>
					The default implementation of <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.IModuleService</codeEntityReference> is <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.ModuleService</codeEntityReference>.
				</para>
				<para>
					To implement a module, simply add a class to your project which inherits from <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.MonoModule</codeEntityReference>:
				</para>
				<code language="cs">
					[code: simple module]
				</code>
				<para>
					The bootstrapper will create the module service which in turn will discover, instantiate, and initialize all modules (using a composition container as described in the next section).
				</para>
				<para>
					<codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.MonoModule</codeEntityReference> inherits from MonoBehaviour so your module can use all Unity features as usual.
					A GameObject is created for each module automatically.
				</para>
				<para>
					The advantage of using modules instead of regular MonoBehaviours attached to GameObjects will be shown in the next sections.
				</para>
			</content>
		</section>

		<section address="CompositionContainer">
			<title>CompositionContainer</title>
			<content>
				<para>
					A <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionContainer</codeEntityReference> provides Dependency Injection (DI) and Inversion-of-Control (IoC).
					DI and IoC are powerful concepts: You just declare the dependency you need and it will be resolved for you.
					This includes instance creation, singleton management, and cascading dependencies.
				</para>
				<para>
					To add a dependency to a module:
				</para>
				<code language="cs">
					[code: import modules]
				</code>
				<para>
					The bootstrapper will create the composition container which then discovers all types it can use for importing.
					A type can be used for importing (as declared by <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Model.ImportPropertyAttribute</codeEntityReference>) if it is exported.
					To export a type, and therefore make it discoverable by the composition container, add an <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Model.ExportAttribute</codeEntityReference> to the type.
					By default, a declared export is inherited to subclasses (that is why our module example in the previous section did not require the export attribute as <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.MonoModule</codeEntityReference> has already delcared it).
				</para>
				<para>
					An object will have its imports resolved when the object is known by the composition container (means: its type is exported) and instances for that object/type are retrieved using the composition container (e.g. using importing).
					This means that each object which is imported has its own imports resolved, and the imports of those imports, and so on.
					Alternative perspective: Each exported type gets its imports resolved if instances of those exported types are retrieved using the composition container.
				</para>
				<para>
					Besides importing, an instance of a type can also be explicitly retrieved from a composition container:
				</para>
				<code language="cs">
					[code: explicitly get instance of type]
				</code>
				<para>
					If you want to export a type which is not under your control, so you cannot apply the export attribute to it, you can also explicitly export a type:
				</para>
				<code language="cs">
					[code: explicitly export of type]
				</code>				
				<para>
					And if you want to export an already created instance instead of a type (for example when constructing the object is complex), you can also explicitly export an object:
				</para>
				<code language="cs">
					[code: explicitly export of object]
				</code>
				<para>
					As shown, exporting and importing is not restricted to modules.
					In fact, any class type can be exported and/or have imports as long as they go through the composition container.
					One special case is a type which inherits from MonoBehaviour.
					Instances of MonoBehaviour cannot be instantiated in a normal way, they need to be added as a component to a GameObject.
					Therefore, if you want to make a MonoBehaviour discoverable, you need to inherit from xxx instead of MonoBehaviour.
					During instantiation, a new GameObject is automatically created to which the MonoBehaviour is then added.
				</para>
				<code language="cs">
					[code: composable monobehaviour]
				</code>
				<para>
					It is also possible to import multiple instances of a type.
					The following example shows how to import all concrete implementations of an interface.
				</para>
				<code language="cs">
					[code: import multiple instances of interface]
				</code>
				<para>
				</para>
				
				
				<para>
					Types discovered by the composition container will not be automatically instantiated.
					A type is only instantiated if it is actually required, e.g. when an import is resolved.
					Besides importing, the composition container can also be used to explicitly get an instance of a type:
				</para>
				<para>
					Each instance which is requested through the composition container will have its imports resolved
				</para>
				
				<para>
					Dependency Injection (DI) and Inversion-of-Control (IoC) are very powerful concepts.
					Instead of finding, creating, and managing all the required objects, instances, singletons, services etc. all by yourself, DI/IoC does it for you.
					Basically, instead of creating instances yourself or using a singleton instance, creating a hard dependency, you just declare what you need.
				</para>
				<para>
					DI/IoC is implemented by <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionContainer</codeEntityReference>.
					It discovers all types you have in your project, adds them to the container, and then creates instances of them as necessary to fill the declared imports.
				</para>
				<para>
					The following example shows two modules where one module requires the other.
					As described in the section above, the modules are created when the bootstrapper starts.
					In this case, the <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionContainer</codeEntityReference> does additional work by resolving all the properties which have the <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Model.ImportPropertyAttribute</codeEntityReference>.
				</para>
				<code language="cs">
					[code: module import]
				</code>
				<para>
					In some cases this level of decoupling might be enough, having a hard dependency but nothing to do with the instantiation.
					However, further decoupling is possible using interfaces.
					The following example shows the use of interfaces to further decouple the modules:
				</para>
				<code language="cs">
					[code: module interfaces]
				</code>
				<para>
					Until now, we were just importing single instances of some types, making it not that much different from good old singletons.
					Besides importing a single instance of a type, we can also import all instances of a type.
					The following example shows how a module imports all concrete implementations of an interface.
				</para>
				<code language="cs">
					[code: multiple interfaces]
				</code>
				<para>
					It also shows that not only module can be imported or have imports.
					In fact, any class type can be imported.
				</para>
				<para>
					The difference between modules () and xxx is that modules are created and initialized as soon as they are added to the xxx while xxx are only created if required (e.g. imported using xxx).
				</para>
			</content>
		</section>

		<section address="ServiceLocator">
			<title>ServiceLocator</title>
			<content>
				<para>
					Your code ist not always in a module.
					It might not even be in a class which can receive imports because it is not known to the xxx.
					The <codeEntityReference qualifyHint="false">T:RI.Framework.Services.ServiceLocator</codeEntityReference> can be used in such cases.
					It is a singleton-like static object which is bound to the xxx so it can be used to get all the instancs you can get using imports.
				</para>
				<code language="cs">
					[code: service locator]
				</code>
			</content>
		</section>

		<section address="IDispatcherService_Messaging">
			<title>IDispatcherService (Messaging)</title>
			<content>
				<para>
					As soon as you start to decouple things, it becomes harder to exchange events and data between them.
					This is where the messaging system comes in, implemented by xxx.
				</para>
				<para>
					The messaging system consists of two parts: registering for message reception and sending the messages.
					The following example shows how to register to receive a message of a certain type:
				</para>
				<code language="cs">
					[code: message registering]
				</code>
				<para>
					Note that you can register for and send any object you like.
					Sending a message is also very easy:
				</para>
				<code language="cs">
					[code: message sending]
				</code>
			</content>
		</section>

		<section address="IDispatcherService_Jobs">
			<title>IDispatcherService (Jobs)</title>
			<content>
				<para>
					Besides providing a messaging system, xxx also allows you to dispatch jobs.
					Dispatched jobs are basically delegates which are put into a queue and processed depending on their priority.
					This can be very helpful to synchronize/serialize operations or when run-to-completion behaviour is required, e.g. state machine transitions which need to occur after everything of the current frame is processed.
				</para>
				<para>
					The following example shows how to put a simple action into the dispatchers queue.
				</para>
			</content>
		</section>

		<relatedTopics />

	</developerConceptualDocument>
</topic>
