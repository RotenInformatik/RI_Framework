<?xml version="1.0" encoding="utf-8"?>

<topic id="3120b15f-18f6-4b5e-92c7-8b51e2bedfb1"
			 revisionNumber="1">
	<developerConceptualDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5"
															 xmlns:xlink="http://www.w3.org/1999/xlink">

		<introduction>
			<para>
				A simple and straigh-forward use of the decoupling features is described in this section.
			</para>
			<alert class="important">
				<para>
					Please consider reading the remarks section of type and member descriptions as they often contain futher explanations and provide more detailed information.
				</para>
			</alert>
			<autoOutline/>
		</introduction>

		<section address="Bootstrapper">
			<title>Bootstrapper</title>
			<content>
				<para>
					A <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Bootstrapper</codeEntityReference> is used to load all the actual decoupling services during scene load (using Unitys Awake() ).
				</para>
				<para>
					Note that the bootstrapper is only required once as it is persistent over all scenes (using Unitys DontDestroyOnLoad() ).
				</para>
				<para>
					Add a new GameObject to the scene and then add the bootstrapper via drag-and-drop from the <legacyItalic>RI.Framework.Unity.dll</legacyItalic>:
				</para>
				<para>
					[screenshot: drag and drop]
				</para>
				<para>
					Alternatively, you can also do this in code by adding <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Bootstrapper</codeEntityReference> as a component to a GameObject:
				</para>
				<code language="cs">
					[code: add bootstrapper in code]
				</code>
				<para>
					When you now start the scene, you can see the bootstrapper object:
				</para>
				<para>
					[screenshot: bootstrapper object]
				</para>
			</content>
		</section>

		<section address="IModuleService">
			<title>IModuleService</title>
			<content>
				<para>
					An implementation of <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.IModuleService</codeEntityReference> is used to implement and manage modules.
					Modules are very similar to singletons as they are started once and then used throughout the game.
					Typical examples for modules are &quot;Controllers&quot; or &quot;Managers&quot; (e.g. PlayerController, EnemyManager, etc.) or globally available services and functionality in general.
				</para>
				<para>
					The default implementation of <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.IModuleService</codeEntityReference> is <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.ModuleService</codeEntityReference>.
				</para>
				<para>
					To implement a module, simply add a class to your project which inherits from <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.MonoModule</codeEntityReference>:
				</para>
				<code language="cs">
					[code: simple module]
				</code>
				<para>
					The bootstrapper will create the module service which in turn will discover, instantiate, and initialize all modules.
				</para>
				<para>
					<codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.MonoModule</codeEntityReference> inherits from MonoBehaviour so your module can use all Unity features as usual.
					A GameObject is created for each module automatically.
				</para>
				<para>
					The advantage of using modules instead of regular MonoBehaviours attached to GameObjects will be shown in the next sections.
				</para>
			</content>
		</section>

		<section address="CompositionContainer">
			<title>CompositionContainer</title>
			<content>
				<para>
					A <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionContainer</codeEntityReference> provides Dependency Injection (DI) and Inversion-of-Control (IoC).
					DI and IoC are powerful concepts: You just declare (using xxx) what you need and it will be resolved for you.
					This includes instantiation, instance management, and cascading dependencies.
				</para>
				<para>
				</para>
				<code language="cs">
					[code: module import]
				</code>
				<para>
				</para>
				
				<para>
					Dependency Injection (DI) and Inversion-of-Control (IoC) are very powerful concepts.
					Instead of finding, creating, and managing all the required objects, instances, singletons, services etc. all by yourself, DI/IoC does it for you.
					Basically, instead of creating instances yourself or using a singleton instance, creating a hard dependency, you just declare what you need.
				</para>
				<para>
					DI/IoC is implemented by <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionContainer</codeEntityReference>.
					It discovers all types you have in your project, adds them to the container, and then creates instances of them as necessary to fill the declared imports.
				</para>
				<para>
					The following example shows two modules where one module requires the other.
					As described in the section above, the modules are created when the bootstrapper starts.
					In this case, the <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionContainer</codeEntityReference> does additional work by resolving all the properties which have the <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Model.ImportPropertyAttribute</codeEntityReference>.
				</para>
				<code language="cs">
					[code: module import]
				</code>
				<para>
					In some cases this level of decoupling might be enough, having a hard dependency but nothing to do with the instantiation.
					However, further decoupling is possible using interfaces.
					The following example shows the use of interfaces to further decouple the modules:
				</para>
				<code language="cs">
					[code: module interfaces]
				</code>
				<para>
					Until now, we were just importing single instances of some types, making it not that much different from good old singletons.
					Besides importing a single instance of a type, we can also import all instances of a type.
					The following example shows how a module imports all concrete implementations of an interface.
				</para>
				<code language="cs">
					[code: multiple interfaces]
				</code>
				<para>
					It also shows that not only module can be imported or have imports.
					In fact, any class type can be imported.
				</para>
				<para>
					The difference between modules () and xxx is that modules are created and initialized as soon as they are added to the xxx while xxx are only created if required (e.g. imported using xxx).
				</para>
			</content>
		</section>

		<section address="ServiceLocator">
			<title>ServiceLocator</title>
			<content>
				<para>
					Your code ist not always in a module.
					It might not even be in a class which can receive imports because it is not known to the xxx.
					The <codeEntityReference qualifyHint="false">T:RI.Framework.Services.ServiceLocator</codeEntityReference> can be used in such cases.
					It is a singleton-like static object which is bound to the xxx so it can be used to get all the instancs you can get using imports.
				</para>
				<code language="cs">
					[code: service locator]
				</code>
			</content>
		</section>

		<section address="IDispatcherService_Messaging">
			<title>IDispatcherService (Messaging)</title>
			<content>
				<para>
					As soon as you start to decouple things, it becomes harder to exchange events and data between them.
					This is where the messaging system comes in, implemented by xxx.
				</para>
				<para>
					The messaging system consists of two parts: registering for message reception and sending the messages.
					The following example shows how to register to receive a message of a certain type:
				</para>
				<code language="cs">
					[code: message registering]
				</code>
				<para>
					Note that you can register for and send any object you like.
					Sending a message is also very easy:
				</para>
				<code language="cs">
					[code: message sending]
				</code>
			</content>
		</section>

		<section address="IDispatcherService_Jobs">
			<title>IDispatcherService (Jobs)</title>
			<content>
				<para>
					Besides providing a messaging system, xxx also allows you to dispatch jobs.
					Dispatched jobs are basically delegates which are put into a queue and processed depending on their priority.
					This can be very helpful to synchronize/serialize operations or when run-to-completion behaviour is required, e.g. state machine transitions which need to occur after everything of the current frame is processed.
				</para>
				<para>
					The following example shows how to put a simple action into the dispatchers queue.
				</para>
			</content>
		</section>

		<relatedTopics />

	</developerConceptualDocument>
</topic>
