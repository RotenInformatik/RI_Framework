<?xml version="1.0" encoding="utf-8"?>

<topic id="8ec8f13f-ef95-4aec-8fc1-9b54dff96e01"
       revisionNumber="1">
    <developerConceptualDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5"
                                 xmlns:xlink="http://www.w3.org/1999/xlink">

        <introduction>
            <para>
                A more advanced use of the decoupling features is described in this section.
            </para>
            <alert class="important">
                <para>
                    Please consider reading the remarks section of type and member descriptions as they often contain futher explanations and provide more detailed information.
                </para>
            </alert>
            <autoOutline />
        </introduction>

        <section address="Bootstrapper">
            <title>Bootstrapper</title>
            <content />
            <sections>
                <section address="Bootstrapper_NoBootstrapper">
                    <title>No Bootstrapper</title>
                    <content>
                        <para />
                        <para>
                            One important thing to know about
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Bootstrapper</codeEntityReference>
                            is that you do not need it.
                            You can use each decoupling service as its own independent standalone service (e.g. if you only want/need one of them).
                            However, you would have to do all the setup and wiring yourself.
                            Following sections will describe how to use each decoupling service as an independent standalone service.
                        </para>
                    </content>
                </section>
                <section address="Bootstrapper_InheritFromBootstrapper">
                    <title>Inherit from Bootstrapper</title>
                    <content>
                        <para />
                        <para>
                            You can inherit from
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Bootstrapper</codeEntityReference>
                            to create a customized bootstrapper which overrides most of its default behaviour.
                            See the documentation of
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Bootstrapper</codeEntityReference>
                            for more information about its default behaviour.
                        </para>
                    </content>
                </section>
                <section address="Bootstrapper_BootstrapperOptions">
                    <title>Bootstrapper options</title>
                    <content>
                        <para />
                        <para>
                            The
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Bootstrapper</codeEntityReference>
                            provides a few options:
                        </para>
                        <mediaLink>
                            <image xlink:href="BootstrapperOptions" />
                        </mediaLink>
                        <para>
                            These options can be helpful if you do want to use the bootstrapper but not all of the decoupling services or if you want to use your own implementation of a service.
                            The only decoupling service always required and created by the bootstrapper is the
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionContainer</codeEntityReference>
                            .
                        </para>
                        <para>
                            The available options are:
                        </para>
                        <list class="bullet">
                            <listItem>
                                <para>
                                    <legacyBold>Logging Service</legacyBold>:
                                    Disabled by default.
                                    Creates the logging service (
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Logging.LogService</codeEntityReference>
                                    ) if enabled.
                                    It is used internally by the framework for logging and therefore can be used to enable/disable all log output generated by the framework.
                                    It is disabled by default to not spam your logs as especially the
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionContainer</codeEntityReference>
                                    can generate an excessive amount of log entries.
                                </para>
                            </listItem>
                            <listItem>
                                <para>
                                    <legacyBold>Module Service</legacyBold>:
                                    Enabled by default.
                                    Creates the modularization service (
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.ModuleService</codeEntityReference>
                                    ) if enabled.
                                </para>
                            </listItem>
                            <listItem>
                                <para>
                                    <legacyBold>Module Initialization</legacyBold>:
                                    Enabled by default.
                                    If enabled, the bootstrapper will automatically initialize the modules during the start if a
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.ModuleService</codeEntityReference>
                                    is available.
                                    <codeEntityReference qualifyHint="false">M:RI.Framework.Services.Modularization.ModuleService.Initialize</codeEntityReference>
                                    will be called.
                                </para>
                            </listItem>
                            <listItem>
                                <para>
                                    <legacyBold>Module Unloading</legacyBold>:
                                    Enabled by default.
                                    If enabled, the bootstrapper will automatically unload the modules during the shutdown if a
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.ModuleService</codeEntityReference>
                                    is available.
                                    <codeEntityReference qualifyHint="false">M:RI.Framework.Services.Modularization.ModuleService.Unload</codeEntityReference>
                                    will be called.
                                </para>
                            </listItem>
                            <listItem>
                                <para>
                                    <legacyBold>Dispatcher Service</legacyBold>:
                                    Enabled by default.
                                    Creates the dispatcher service (
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Dispatcher.DispatcherService</codeEntityReference>
                                    ) if enabled.
                                </para>
                            </listItem>
                            <listItem>
                                <para>
                                    <legacyBold>Scripting Catalog</legacyBold>:
                                    Enabled by default.
                                    Adds a
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Catalogs.ScriptingCatalog</codeEntityReference>
                                    to the
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionContainer</codeEntityReference>
                                    if enabled.
                                    The purpose and use of catalogs is described below.
                                </para>
                            </listItem>
                            <listItem>
                                <para>
                                    <legacyBold>Service Locator Binding</legacyBold>:
                                    Enabled by default.
                                    Binds the
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.ServiceLocator</codeEntityReference>
                                    to
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionContainer</codeEntityReference>
                                    if enabled.
                                </para>
                            </listItem>
                        </list>
                    </content>
                </section>
            </sections>
        </section>

        <section address="CompositionContainer">
            <title>CompositionContainer</title>
            <content />
            <sections>
                <section address="CompositionContainer_StandaloneUse">
                    <title>Standalone use</title>
                    <content>
                        <para />
                        <para>
                            You can use a
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionContainer</codeEntityReference>
                            as a standalone service.
                            Just create an instance:
                        </para>
                        <code language="cs">
                            <![CDATA[
CompositionContainer container = new CompositionContainer();
          ]]>
                        </code>
                        <para>
                            It is also possible to create multiple composition containers.
                            Each composition container will be completely independent of each other and they will share neither exports nor imports.
                        </para>
                    </content>
                </section>
                <section address="CompositionContainer_Catalogs">
                    <title>Catalogs</title>
                    <content>
                        <para />
                        <para>
                            Catalogs are used to tell a
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionContainer</codeEntityReference>
                            where to look for exports.
                            Only exports found in catalogs, which are added to the composition container, will be discovered and used.
                            Catalogs are added using
                            <codeEntityReference qualifyHint="false">M:RI.Framework.Composition.CompositionContainer.AddCatalog(RI.Framework.Composition.CompositionCatalog)</codeEntityReference>
                            and removed using
                            <codeEntityReference qualifyHint="false">M:RI.Framework.Composition.CompositionContainer.RemoveCatalog(RI.Framework.Composition.CompositionCatalog)</codeEntityReference>
                            .
                            Multiple different catalogs can be used at the same time.
                        </para>
                        <para>
                            Catalogs can be added and removed dynamically, as shown above.
                            When the available catalogs change, the available exports in the corresponding
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionContainer</codeEntityReference>
                            will be updated as well, adding or removing exports dynamically.
                        </para>
                        <para>
                            All catalogs inherit from
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionCatalog</codeEntityReference>
                            .
                            You can use one or more of the built-in catalogs and/or implement your own.
                        </para>
                        <para>
                            The following built-in catalogs exist:
                        </para>
                        <list class="bullet">
                            <listItem>
                                <para>
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Catalogs.ScriptingCatalog</codeEntityReference>
                                    :
                                    All exported types of the Unity scripting assemblies are used for discovery.
                                    Unity scripting assemblies are all assemblies which start with the name
                                    <legacyItalic>Assembly-CSharp</legacyItalic>.
                                    Therefore, this catalog makes possible the &quot;magic&quot; discovery of all the types you add to your Unity project.
                                    This catalog is added by default by the
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Bootstrapper</codeEntityReference>
                                    .
                                </para>
                            </listItem>
                            <listItem>
                                <para>
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Catalogs.AssemblyCatalog</codeEntityReference>
                                    :
                                    All exported types of one or more specified assemblies are used for discovery.
                                </para>
                            </listItem>
                            <listItem>
                                <para>
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Catalogs.DirectoryCatalog</codeEntityReference>
                                    :
                                    All managed DLL assembly files in a specified directory will be loaded and their exported types used for discovery.
                                </para>
                            </listItem>
                            <!--<listItem>
                                <para>
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Catalogs.FileCatalog</codeEntityReference>:
                                    All exported types of a specified managed DLL assembly file are used for discovery.
                                </para>
                            </listItem>-->
                            <listItem>
                                <para>
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Catalogs.TypeCatalog</codeEntityReference>
                                    :
                                    A catalog where one or more exports can be added manually by directly specifying types.
                                </para>
                            </listItem>
                            <listItem>
                                <para>
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Catalogs.InstanceCatalog</codeEntityReference>
                                    :
                                    A catalog where one or more exports can be added manually by directly specifying instances.
                                </para>
                            </listItem>
                            <!--<listItem>
                                <para>
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Catalogs.AppDomainCatalog</codeEntityReference>:
                                    All exported types of all assemblies loaded into the current application domain will be used for discovery.
                                </para>
                            </listItem>-->
                            <!--<listItem>
                                <para>
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Catalogs.AggregateCatalog</codeEntityReference>:
                                    Combines multiple catalogs so they can be used as one.
                                </para>
                            </listItem>-->
                        </list>
                    </content>
                </section>
                <section address="CompositionContainer_Recomposition">
                    <title>Recomposition</title>
                    <content>
                        <para />
                        <para>
                            By default, all imports (
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Model.ImportAttribute</codeEntityReference>
                            ) are recomposable.
                            This means that when the available exports of a
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionContainer</codeEntityReference>
                            is changed (e.g. by adding or removing a catalog), the imports are updated automatically.
                        </para>
                        <para>
                            If a type implements
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Model.IImporting</codeEntityReference>
                            , it is notified when one or more of its imports have been updated.
                            The following example shows how to track recompositions:
                        </para>
                        <code language="cs">
                            <![CDATA[
using RI.Framework.Composition;
using RI.Framework.Composition.Model;
using RI.Framework.Services;
using RI.Framework.Services.Modularization;


[Export]
public interface IEnemyAI
{
}


[Export]
public class EnemyManager : MonoModule, IImporting
{
    [Import]
    public Import ImportedAIs { get; set; }

    public IEnemyAI[] UsedAIs;
  
    public void ImportsResolving (CompositionFlags composition, bool updated)
    {
        // called immediately before imports are resolved
    }
  
    public void ImportsResolved (CompositionFlags composition, bool updated)
    {
        // called immediately after imports were resolved
        
        if(updated)
        {
            this.UsedAIs = this.ImportedAIs.ToArray<IEnemyAI>();
        }
    }
}
          ]]>
                        </code>
                    </content>
                </section>
                <section address="CompositionContainer_NamedExportsAndImports">
                    <title>Named exports and imports</title>
                    <content>
                        <para />
                        <para>
                            So far, we have seen how to identify exports and imports using their types.
                            Besides that, it is also possible to identify them using names.
                            The following example shows how to use names instead of types:
                        </para>
                        <code language="cs">
                            <![CDATA[
using RI.Framework.Composition;
using RI.Framework.Composition.Model;
using RI.Framework.Services;
using RI.Framework.Services.Modularization;


[Export("MyRules")]
public class GameRules : MonoModule
{
}


[Export]
public class EnemyManager : MonoModule
{
    [Import("MyRules")]
    public GameRules Rules { get; set; }
}
          ]]>
                        </code>
                    </content>
                </section>
                <section address="CompositionContainer_MultiExport">
                    <title>Multi-export</title>
                    <content>
                        <para />
                        <para>
                            The same type or instance can also be exported multiple times under different types or names:
                        </para>
                        <code language="cs">
                            <![CDATA[
using RI.Framework.Composition;
using RI.Framework.Composition.Model;
using RI.Framework.Services;
using RI.Framework.Services.Modularization;


public interface IGameRules
{
}


[Export] // default export (GameRules)
[Export("MyRules")] // named export (MyRules)
[Export(typeof(IGameRules))] // export as different type (IGameRules)
public class GameRules : MonoModule, IGameRules
{
}


[Export]
public class EnemyManager : MonoModule
{
    // all of the following imports will get the same instance of the GameRules type

    [Import]
    public GameRules Rules { get; set; }
    
    [Import("MyRules")]
    public GameRules Rules { get; set; }
    
    [Import(typeof(IGameRules))]
    public GameRules Rules { get; set; }
}
          ]]>
                        </code>
                    </content>
                </section>
            </sections>
        </section>

        <section address="ModuleService">
            <title>ModuleService</title>
            <content />
            <sections>
                <section address="ModuleService_StandaloneUse">
                    <title>Standalone use</title>
                    <content>
                        <para />
                        <para>
                            You can use the
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.ModuleService</codeEntityReference>
                            as a standalone service.
                            Just create an instance:
                        </para>
                        <code language="cs">
                            <![CDATA[
ModuleService moduleService = new ModuleService();
                            ]]>
                        </code>
                        <para>
                            It is also possible to create multiple independent instances of
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.ModuleService</codeEntityReference>
                            .
                        </para>
                    </content>
                </section>
                <section address="ModuleService_DependencyOnCompositionContainer">
                    <title>Dependency on CompositionContainer</title>
                    <content>
                        <para />
                        <para>
                            The
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.ModuleService</codeEntityReference>
                            has an import property to import all implementations of
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.IModule</codeEntityReference>
                            .
                            It also implements
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Model.IImporting</codeEntityReference>
                            , making it aware when the imported
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.IModule</codeEntityReference>
                            s were updated/recomposed.
                            Therefore, it is not necessary to add the modules explicitly as they are automatically discovered by the
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionContainer</codeEntityReference>
                            and imported into
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.ModuleService</codeEntityReference>
                            .
                        </para>
                        <para>
                            If
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.ModuleService</codeEntityReference>
                            is not contained in a
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionContainer</codeEntityReference>
                            , the modules must be manually added and removed using
                            <codeEntityReference qualifyHint="false">M:RI.Framework.Services.Modularization.ModuleService.AddModule(RI.Framework.Services.Modularization.IModule)</codeEntityReference>
                            and
                            <codeEntityReference qualifyHint="false">M:RI.Framework.Services.Modularization.ModuleService.RemoveModule(RI.Framework.Services.Modularization.IModule)</codeEntityReference>
                            .
                        </para>
                        <para>
                            It is possible to use both importing and explicit add/remove but you cannot explicitly remove a module which is imported.
                            The behaviour is undefined if a module is imported and explicitly added.
                        </para>
                    </content>
                </section>
                <section address="ModuleService_ModuleImplementation">
                    <title>Module implementation</title>
                    <content>
                        <para />
                        <para>
                            There are two base implementations for modules which implement
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.IModule</codeEntityReference>
                            :
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.MonoModule</codeEntityReference>
                            and
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.Module</codeEntityReference>
                            .
                            You can use one of these base classes to implement your modules or implement
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.IModule</codeEntityReference>
                            directly.
                        </para>
                        <para>
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.MonoModule</codeEntityReference>
                            is used for modules which also need to be a <legacyItalic>MonoBehaviour</legacyItalic>.
                            When such modules are instantiated, a <legacyItalic>GameObject</legacyItalic> is automatically created to which the module instance is attached (one
                            <legacyItalic>GameObject</legacyItalic> per module).
                        </para>
                        <para>
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.Module</codeEntityReference>
                            is used for modules which do not require to be a <legacyItalic>MonoBehaviour</legacyItalic>
                            .
                        </para>
                    </content>
                </section>
                <section address="ModuleService_InitializationAndUnloading">
                    <title>Initialization and unloading</title>
                    <content>
                        <para />
                        <para>
                            The initialization and unloading of modules should be managed by the module service.
                            Do not call
                            <codeEntityReference qualifyHint="false">M:RI.Framework.Services.Modularization.IModule.Initialize</codeEntityReference>
                            or
                            <codeEntityReference qualifyHint="false">M:RI.Framework.Services.Modularization.IModule.Unload</codeEntityReference>
                            on a module directly.
                        </para>
                        <para>
                            The module service knows whether a module is initialized or not through its
                            <codeEntityReference qualifyHint="false">P:RI.Framework.Services.Modularization.IModule.IsInitialized</codeEntityReference>
                            property.
                            At a certain point during startup, the modules are going to be initialized (e.g. when the bootstrapper calls
                            <codeEntityReference qualifyHint="false">M:RI.Framework.Services.Modularization.ModuleService.Initialize</codeEntityReference>
                            ).
                            This will initialize all modules which are known to the module service at this point in time.
                            If a module is added later, the added module is also initialized immediately after it was added (but only if the other modules were previously initialized).
                        </para>
                        <para>
                            The same applies for unloading in a somewhat reversed fashion:
                            At a certain point during shutdown, the modules are going to be unloaded (e.g. when the bootstrapper calls
                            <codeEntityReference qualifyHint="false">M:RI.Framework.Services.Modularization.ModuleService.Unload</codeEntityReference>
                            ).
                            This will unload all modules which are known to the module service at this point in time.
                            If a module was removed earlier, the removed module was already unloaded during removal.
                        </para>
                        <para>
                            This mechanism ensures that modules are always properly initialized and unloaded, regardless when they were added/removed.
                        </para>
                    </content>
                </section>
            </sections>
        </section>

        <section address="DispatcherService">
            <title>DispatcherService</title>
            <content />
            <sections>
                <section address="IDispatcherService_StandaloneUse">
                    <title>Standalone use</title>
                    <content>
                        <para />
                        <para>
                            You can use the
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Dispatcher.DispatcherService</codeEntityReference>
                            as a standalone service.
                            Just create an instance:
                        </para>
                        <code language="cs">
                            <![CDATA[
DispatcherService dispatcher = new DispatcherService();
                            ]]>
                        </code>
                        <para>
                            It is also possible to create multiple independent instances of
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Dispatcher.DispatcherService</codeEntityReference>
                            .
                        </para>
                    </content>
                </section>
                <section address="DispatcherService_IDispatcherOperation">
                    <title>IDispatcherOperation</title>
                    <content>
                        <para />
                        <para>
                            When a message is broadcasted or an operation is dispatched, the dispatcher service returns an
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Dispatcher.IDispatcherOperation</codeEntityReference>
                            object.
                            This object provides some advanced control over the broadcast of messages or execution of operations respectively.
                            Each broadcast and each dispatch will return its own unique
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Dispatcher.IDispatcherOperation</codeEntityReference>
                            .
                        </para>
                        <para>
                            You can cancel a broadcast or execution:
                        </para>
                        <code language="cs">
                            <![CDATA[
IDispatcherOperation op = dispatcher.Dispatch(SomeMethod);
op.Cancel(); // cancel operation
                            ]]>
                        </code>
                        <para>
                            You can reschedule a broadcast or execution so that it is delayed for a specified amount of time or until a specified point in time:
                        </para>
                        <code language="cs">
                            <![CDATA[
IDispatcherOperation op = dispatcher.Dispatch(SomeMethod);
op.Reschedule(1000); // delay execution by 1000 milliseconds
                            ]]>
                        </code>
                        <para>
                            You can set a timeout (helpful for lower priorities which do not guarantee execution):
                        </para>
                        <code language="cs">
                            <![CDATA[
IDispatcherOperation op = dispatcher.Dispatch(DispatcherPriority.Idle, SomeMethod);
op.Timeout(1000); // cancel execution if not started after 1000 milliseconds (e.g. the dispatcher never becomes idle)
                            ]]>
                        </code>
                        <para>
                            You can set a callback:
                        </para>
                        <code language="cs">
                            <![CDATA[
IDispatcherOperation op = dispatcher.DispatchFunc(DispatcherPriority.Background, SomeMethodWithReturnValue);
op.OnFinished((_op, _args) =>
{
    // the callback is always executed on Unitys main/foreground thread
    
    // evaluate how the operation finished
    Debug.Log("Finished: " + _op.Status);
    
    // get the return value of the executed method
    Debug.Log("Result: " + _op.Result);
    
    // lets broadcast something from the callback
    dispatcher.Broadcast(SomeEventData);
});
                            ]]>
                        </code>
                        <para>
                            You can chain all these methods fluently:
                        </para>
                        <code language="cs">
                            <![CDATA[
dispatcher.Dispatch(SomeMethod)
          .Timeout(1000)
          .OnFinished((_op, _args) => MyCallbackMethod);
                            ]]>
                        </code>
                        <para>
                            Note that for broadcasts and dispatchs of priority <legacyItalic>Now</legacyItalic>, the returned
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Dispatcher.IDispatcherOperation</codeEntityReference>
                            is only useful for getting the results of dispatched methods because the the operation will already be completed when the
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Dispatcher.IDispatcherOperation</codeEntityReference>
                            is returned.
                        </para>
                    </content>
                </section>
            </sections>
        </section>

        <relatedTopics />

    </developerConceptualDocument>
</topic>