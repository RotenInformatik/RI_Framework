<?xml version="1.0" encoding="utf-8"?>

<topic id="dcd0ab6e-87ba-42ab-8810-ad01d32dc132"
       revisionNumber="1">
    <developerConceptualDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5"
                                 xmlns:xlink="http://www.w3.org/1999/xlink">

        <introduction>
            <autoOutline />
        </introduction>

        <section address="Purpose">
            <title>Purpose</title>
            <content>
                <para>
                    A
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionContainer</codeEntityReference>
                    provides Dependency Injection (DI) and Inversion-of-Control (IoC).
                </para>
                <para>
                    DI and IoC are powerful concepts: You just declare the dependency you need and it will be resolved and assigned for you.
                    This includes instance creation, singleton management, and cascading dependencies.
                </para>
            </content>
        </section>

        <section address="Usage">
            <title>Usage</title>
            <content>
                <para>
                    The following example shows how a dependency is added to a module:
                </para>
                <code language="cs">
                    <![CDATA[
using RI.Framework.Composition;
using RI.Framework.Composition.Model;
using RI.Framework.Services;
using RI.Framework.Services.Modularization;


[Export]
public class GameRules : MonoModule
{
}


[Export]
public class EnemyManager : MonoModule
{
    [Import]
    public GameRules Rules { get; set; }
  
    // EnemyManager has a dependency to GameRules which will be automatically resolved and assigned
    // the Rules property can be used everywhere inside EnemyManager, except its constructor
}
          ]]>
                </code>
            </content>
        </section>

        <section address="HowItWorks">
            <title>How it works</title>
            <content>
                <para>
                    The bootstrapper will create the composition container which then discovers all types it can use for importing.
                    A type can be used for importing (as declared by
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Model.ImportAttribute</codeEntityReference>
                    ) if it is exported.
                    To export a type, and therefore make it discoverable by the composition container, add an
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Model.ExportAttribute</codeEntityReference>
                    to the type.
                </para>
                <para>
                    An object will have its imports resolved and assigned when it is known by the composition container (means: the object is exported) and instances for that object (or its type respectively) are retrieved using the composition container (e.g. using importing).
                    This means that each object which is imported has its own imports resolved, and the imports of those imports, and so on.
                    Alternative perspective: Each exported object gets its imports resolved if instances of those exported objects are retrieved using the composition container.
                </para>
            </content>
        </section>

        <section address="StandaloneUse">
            <title>Standalone use</title>
            <content>
                <para>
                    You can use a
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionContainer</codeEntityReference>
                    as a standalone service.
                    Just create an instance:
                </para>
                <code language="cs">
                    <![CDATA[
CompositionContainer container = new CompositionContainer();
          ]]>
                </code>
            </content>
        </section>

        <section address="MultipleInstances">
            <title>Multiple instances</title>
            <content>
                <para>
                    It is also possible to create multiple composition containers.
                    Each composition container will be completely independent of each other and they will share neither exports nor imports.
                </para>
            </content>
        </section>

        <section address="UsageBeyondModules">
            <title>Usage beyond modules</title>
            <content>
                <para>
                    Exporting and importing is not restricted to modules.
                    Any class type can be exported and/or have imports as long as they go through the composition container.
                </para>
                <para>
                    One special case is a type which inherits from <legacyItalic>MonoBehaviour</legacyItalic>.
                    Instances of <legacyItalic>MonoBehaviour</legacyItalic> cannot be instantiated in a normal way, they need to be added as a component to a
                    <legacyItalic>GameObject</legacyItalic>.
                    Therefore, if you want to make a <legacyItalic>MonoBehaviour</legacyItalic> discoverable, you need to inherit from
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.ComposableMonoBehaviour</codeEntityReference>
                    instead of <legacyItalic>MonoBehaviour</legacyItalic>.
                    During instantiation, a new <legacyItalic>GameObject</legacyItalic> is automatically created to which the
                    <legacyItalic>MonoBehaviour</legacyItalic> is then added.
                </para>
                <code language="cs">
                    <![CDATA[
using RI.Framework.Composition;
using RI.Framework.Composition.Model;
using RI.Framework.Services;
using RI.Framework.Services.Modularization;


[Export]
public class Raycaster : ComposableMonoBehaviour
{
}


[Export]
public class EnemyManager : MonoModule
{
    protected override void Initialize ()
    {
        base.Initialize();
        
        Raycaster raycaster = this.Container.GetExport<Raycaster>();
    }
}
          ]]>
                </code>
                <para>
                    Another special case is that only modules are automatically instantiated and initialized during startup (by the bootstrapper).
                    Any other type contained in a composition container is only instantiated when an actual instance is required (importing or explicit retrieval).
                    Therefore, if a type in a composition container is never imported nor requested, no instances of that type will be created.
                </para>
            </content>
        </section>

        <section address="ExplicitExportRetrieval">
            <title>Explicit export retrieval</title>
            <content>
                <para>
                    Besides importing, an instance of a type can also be explicitly retrieved from a composition container (note that the composition container can contain itself):
                </para>
                <code language="cs">
                    <![CDATA[
using RI.Framework.Composition;
using RI.Framework.Composition.Model;
using RI.Framework.Services;
using RI.Framework.Services.Modularization;


[Export]
public class GameRules : MonoModule
{
}


[Export]
public class EnemyManager : MonoModule
{
    [Import]
    public CompositionContainer Container { get; set; }

    protected override void Initialize ()
    {
        base.Initialize();
        
        GameRules rules = this.Container.GetExport<GameRules>();
    }
}
          ]]>
                </code>
            </content>
        </section>

        <section address="ExplicitExportDefinition">
            <title>Explicit export definition</title>
            <content>
                <para>
                    If you want to export a type which is not under your control, so you cannot apply
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Model.ExportAttribute</codeEntityReference>
                    to it, you can also explicitly export a type:
                </para>
                <code language="cs">
                    <![CDATA[
using RI.Framework.Composition;
using RI.Framework.Composition.Model;
using RI.Framework.Services;
using RI.Framework.Services.Modularization;


[Export]
public class EnemyManager : MonoModule
{
    [Import]
    public CompositionContainer Container { get; set; }

    protected override void Initialize ()
    {
        base.Initialize();
        
        this.Container.AddExport(typeof(SomeOtherType), typeof(SomeOtherType), false);
    }
}
          ]]>
                </code>
                <para>
                    And if you want to export an already created instance instead of a type (e.g. when constructing the object is complex), you can also explicitly export an instance of a type:
                </para>
                <code language="cs">
                    <![CDATA[
using RI.Framework.Composition;
using RI.Framework.Composition.Model;
using RI.Framework.Services;
using RI.Framework.Services.Modularization;


[Export]
public class EnemyManager : MonoModule
{
    [Import]
    public CompositionContainer Container { get; set; }

    protected override void Initialize ()
    {
        base.Initialize();
        
        this.Container.AddExport(new SomeOtherType("Test", 123, SomeEnum.Default), typeof(SomeOtherType));
    }
}
          ]]>
                </code>
            </content>
        </section>

        <section address="ImportMultipleInstances">
            <title>Import multiple instances</title>
            <content>
                <para>
                    It is also possible to import multiple instances of a type.
                    The following example shows how to import all concrete implementations of an interface:
                </para>
                <code language="cs">
                    <![CDATA[
using RI.Framework.Composition;
using RI.Framework.Composition.Model;
using RI.Framework.Services;
using RI.Framework.Services.Modularization;


[Export]
public interface IEnemyAI
{
}


public class SmartEnemyAI : IEnemyAI
{
}


public class DumbEnemyAI : IEnemyAI
{
}


[Export]
public class EnemyManager : MonoModule
{
    // importing multiple instances is only possible with the Import proxy in order to be AOT-compatible
    // this is also why we need to explicitly specify the desired type

    [Import(typeof(IEnemyAI))]
    public Import AIs { get; set; }
  
    protected override void Initialize ()
    {
        base.Initialize();
        
        // one way is to retrieve all instances as an array
        IEnemyAI[] aiArray = this.AIs.ToArray<IEnemyAI>();
        
        // ...or a list
        List<IEnemyAI> aiList = this.AIs.ToList<IEnemyAI>();
        
        // ...or by enumerating them
        foreach(var ai in this.AIs.Values<IEnemyAI>())
        {
        }
        
        // ...or by picking the first available
        IEnemyAI first = this.AIs.Value<IEnemyAI>();
    }
}
          ]]>
                </code>
            </content>
        </section>

        <section address="CircularDependencies">
            <title>Circular dependencies</title>
            <content>
                <para>
                    Circular dependencies are possible.
                    For example, object A can import object B and object B can import object A.
                </para>
            </content>
        </section>

        <section address="Catalogs">
            <title>Catalogs</title>
            <content>
                <para>
                    Catalogs are used to tell a
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionContainer</codeEntityReference>
                    where to look for exports.
                    Only exports found in catalogs, which are added to the composition container, will be discovered and used.
                    Catalogs are added using
                    <codeEntityReference qualifyHint="false">M:RI.Framework.Composition.CompositionContainer.AddCatalog(RI.Framework.Composition.CompositionCatalog)</codeEntityReference>
                    and removed using
                    <codeEntityReference qualifyHint="false">M:RI.Framework.Composition.CompositionContainer.RemoveCatalog(RI.Framework.Composition.CompositionCatalog)</codeEntityReference>
                    .
                    Multiple different catalogs can be used at the same time.
                </para>
                <para>
                    Catalogs can be added and removed dynamically, as shown above.
                    When the available catalogs change, the available exports in the corresponding
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionContainer</codeEntityReference>
                    will be updated as well, adding or removing exports dynamically.
                </para>
                <para>
                    All catalogs inherit from
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionCatalog</codeEntityReference>
                    .
                    You can use one or more of the built-in catalogs and/or implement your own.
                </para>
                <para>
                    The following built-in catalogs exist:
                </para>
                <list class="bullet">
                    <listItem>
                        <para>
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Catalogs.ScriptingCatalog</codeEntityReference>
                            :
                            All exported types of the Unity scripting assemblies are used for discovery.
                            Unity scripting assemblies are all assemblies which start with the name
                            <legacyItalic>Assembly-CSharp</legacyItalic>.
                            Therefore, this catalog makes possible the &quot;magic&quot; discovery of all the types you add to your Unity project.
                            This catalog is added by default by the
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Bootstrapper</codeEntityReference>
                            .
                        </para>
                    </listItem>
                    <listItem>
                        <para>
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Catalogs.AssemblyCatalog</codeEntityReference>
                            :
                            All exported types of one or more specified assemblies are used for discovery.
                        </para>
                    </listItem>
                    <listItem>
                        <para>
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Catalogs.DirectoryCatalog</codeEntityReference>
                            :
                            All managed DLL assembly files in a specified directory will be loaded and their exported types used for discovery.
                        </para>
                    </listItem>
                    <!--<listItem>
                                <para>
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Catalogs.FileCatalog</codeEntityReference>:
                                    All exported types of a specified managed DLL assembly file are used for discovery.
                                </para>
                            </listItem>-->
                    <listItem>
                        <para>
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Catalogs.TypeCatalog</codeEntityReference>
                            :
                            A catalog where one or more exports can be added manually by directly specifying types.
                        </para>
                    </listItem>
                    <listItem>
                        <para>
                            <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Catalogs.InstanceCatalog</codeEntityReference>
                            :
                            A catalog where one or more exports can be added manually by directly specifying instances.
                        </para>
                    </listItem>
                    <!--<listItem>
                                <para>
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Catalogs.AppDomainCatalog</codeEntityReference>:
                                    All exported types of all assemblies loaded into the current application domain will be used for discovery.
                                </para>
                            </listItem>-->
                    <!--<listItem>
                                <para>
                                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Catalogs.AggregateCatalog</codeEntityReference>:
                                    Combines multiple catalogs so they can be used as one.
                                </para>
                            </listItem>-->
                </list>
            </content>
        </section>

        <section address="Recomposition">
            <title>Recomposition</title>
            <content>
                <para>
                    By default, all imports (
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Model.ImportAttribute</codeEntityReference>
                    ) are recomposable.
                    This means that when the available exports of a
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionContainer</codeEntityReference>
                    is changed (e.g. by adding or removing a catalog), the imports are updated automatically.
                </para>
                <para>
                    If a type implements
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Model.IImporting</codeEntityReference>
                    , it is notified when one or more of its imports have been updated.
                    The following example shows how to track recompositions:
                </para>
                <code language="cs">
                    <![CDATA[
using RI.Framework.Composition;
using RI.Framework.Composition.Model;
using RI.Framework.Services;
using RI.Framework.Services.Modularization;


[Export]
public interface IEnemyAI
{
}


[Export]
public class EnemyManager : MonoModule, IImporting
{
    [Import]
    public Import ImportedAIs { get; set; }

    public IEnemyAI[] UsedAIs;
  
    public void ImportsResolving (CompositionFlags composition, bool updated)
    {
        // called immediately before imports are resolved
    }
  
    public void ImportsResolved (CompositionFlags composition, bool updated)
    {
        // called immediately after imports were resolved
        
        if(updated)
        {
            this.UsedAIs = this.ImportedAIs.ToArray<IEnemyAI>();
        }
    }
}
          ]]>
                </code>
            </content>
        </section>

        <section address="NamedExportsAndImports">
            <title>Named exports and imports</title>
            <content>
                <para>
                    So far, we have seen how to identify exports and imports using their types.
                    Besides that, it is also possible to identify them using names.
                    The following example shows how to use names instead of types:
                </para>
                <code language="cs">
                    <![CDATA[
using RI.Framework.Composition;
using RI.Framework.Composition.Model;
using RI.Framework.Services;
using RI.Framework.Services.Modularization;


[Export("MyRules")]
public class GameRules : MonoModule
{
}


[Export]
public class EnemyManager : MonoModule
{
    [Import("MyRules")]
    public GameRules Rules { get; set; }
}
          ]]>
                </code>
            </content>
        </section>

        <section address="MultiExport">
            <title>Multi-export</title>
            <content>
                <para>
                    The same type or instance can also be exported multiple times under different types or names:
                </para>
                <code language="cs">
                    <![CDATA[
using RI.Framework.Composition;
using RI.Framework.Composition.Model;
using RI.Framework.Services;
using RI.Framework.Services.Modularization;


public interface IGameRules
{
}


[Export] // default export (GameRules)
[Export("MyRules")] // named export (MyRules)
[Export(typeof(IGameRules))] // export as different type (IGameRules)
public class GameRules : MonoModule, IGameRules
{
}


[Export]
public class EnemyManager : MonoModule
{
    // all of the following imports will get the same instance of the GameRules type

    [Import]
    public GameRules Rules { get; set; }
    
    [Import("MyRules")]
    public GameRules Rules { get; set; }
    
    [Import(typeof(IGameRules))]
    public GameRules Rules { get; set; }
}
          ]]>
                </code>
            </content>
        </section>

        <relatedTopics />

    </developerConceptualDocument>
</topic>