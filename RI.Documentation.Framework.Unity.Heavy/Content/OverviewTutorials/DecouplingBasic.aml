<?xml version="1.0" encoding="utf-8"?>

<topic id="3120b15f-18f6-4b5e-92c7-8b51e2bedfb1"
       revisionNumber="1">
    <developerConceptualDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5"
                                 xmlns:xlink="http://www.w3.org/1999/xlink">

        <introduction>
            <para>
                A simple and straigh-forward use of the decoupling features is described in this section.
            </para>
            <alert class="important">
                <para>
                    Please consider reading the remarks section of type and member descriptions as they often contain futher explanations and provide more detailed information.
                </para>
            </alert>
            <autoOutline />
        </introduction>

        <section address="Bootstrapper">
            <title>Bootstrapper</title>
            <content>
                <para>
                    A
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Bootstrapper</codeEntityReference>
                    is used to load all the actual decoupling services during scene load (using Unitys
                    <legacyItalic>Awake()</legacyItalic> ).
                </para>
                <para>
                    Note that the bootstrapper is only required once as it is persistent over all scenes (using Unitys
                    <legacyItalic>DontDestroyOnLoad()</legacyItalic> ).
                </para>
                <para>
                    The bootstrapper is added to a <legacyItalic>GameObject</legacyItalic> in a scene using drag-and-drop from
                    <legacyItalic>RI.Framework.Unity.dll</legacyItalic>:
                </para>
                <mediaLink>
                    <image xlink:href="BootstrapperDragDrop" />
                </mediaLink>
                <para>
                    Alternatively, it can also be done in code by adding
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Bootstrapper</codeEntityReference>
                    as a component to a <legacyItalic>GameObject</legacyItalic>:
                </para>
                <code language="cs">
                    <![CDATA[
GameObject go = new GameObject();
go.AddComponent<Bootstrapper>();
          ]]>
                </code>
                <para>
                    After the scene load, the bootstrapper can be seen in the list of objects:
                </para>
                <mediaLink>
                    <image xlink:href="BootstrapperObject" />
                </mediaLink>
            </content>
        </section>

        <section address="ModuleService">
            <title>ModuleService</title>
            <content>
                <para>
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.ModuleService</codeEntityReference>
                    is used to implement and manage modules.
                    Modules are very similar to singletons as they are instantiated and started once and then used throughout the game.
                    Typical examples for modules are &quot;Controllers&quot; or &quot;Managers&quot; (e.g. PlayerController, EnemyManager, etc.) or globally available services and functionality in general.
                </para>
                <para>
                    To implement a module, simply add a class to your project which inherits from
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.MonoModule</codeEntityReference>
                    :
                </para>
                <code language="cs">
                    <![CDATA[
using RI.Framework.Services;
using RI.Framework.Services.Modularization;


public class EnemyManager : MonoModule
{
    protected override void Initialize ()
    {
        base.Initialize();
        
        // called when the module is initialized (e.g. when the bootstrapper starts)
    }
  
    protected override void Unload ()
    {
        base.Unload();
    
        // called when the module is unloaded (e.g. when the game ends)
    }
}
          ]]>
                </code>
                <para>
                    The bootstrapper will create the module service which in turn will discover, instantiate, and initialize all modules (using a composition container as described in the next section).
                </para>
                <para>
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Modularization.MonoModule</codeEntityReference>
                    inherits from <legacyItalic>MonoBehaviour</legacyItalic> so a module can use all Unity features as usual.
                    A <legacyItalic>GameObject</legacyItalic> is created for each module automatically.
                </para>
                <para>
                    The advantage of using modules instead of regular <legacyItalic>MonoBehaviour</legacyItalic>s attached to
                    <legacyItalic>GameObject</legacyItalic>s will be shown in the next section.
                </para>
            </content>
        </section>

        <section address="CompositionContainer">
            <title>CompositionContainer</title>
            <content>
                <para>
                    A
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.CompositionContainer</codeEntityReference>
                    provides Dependency Injection (DI) and Inversion-of-Control (IoC).
                </para>
                <para>
                    DI and IoC are powerful concepts: You just declare the dependency you need and it will be resolved and assigned for you.
                    This includes instance creation, singleton management, and cascading dependencies.
                </para>
                <para>
                    To add a dependency to a module:
                </para>
                <code language="cs">
                    <![CDATA[
using RI.Framework.Composition;
using RI.Framework.Composition.Model;
using RI.Framework.Services;
using RI.Framework.Services.Modularization;


[Export]
public class GameRules : MonoModule
{
}


[Export]
public class EnemyManager : MonoModule
{
    [Import]
    public GameRules Rules { get; set; }
  
    // EnemyManager has a dependency to GameRules which will be automatically resolved and assigned
    // the Rules property can be used everywhere inside EnemyManager, except its constructor
}
          ]]>
                </code>
                <para>
                    The bootstrapper will create the composition container which then discovers all types it can use for importing.
                    A type can be used for importing (as declared by
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Model.ImportAttribute</codeEntityReference>
                    ) if it is exported.
                    To export a type, and therefore make it discoverable by the composition container, add an
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Model.ExportAttribute</codeEntityReference>
                    to the type.
                </para>
                <para>
                    An object will have its imports resolved and assigned when it is known by the composition container (means: the object is exported) and instances for that object (or its type respectively) are retrieved using the composition container (e.g. using importing).
                    This means that each object which is imported has its own imports resolved, and the imports of those imports, and so on.
                    Alternative perspective: Each exported object gets its imports resolved if instances of those exported objects are retrieved using the composition container.
                </para>
                <para>
                    Besides importing, an instance of a type can also be explicitly retrieved from a composition container (note that the composition container can contain itself):
                </para>
                <code language="cs">
                    <![CDATA[
using RI.Framework.Composition;
using RI.Framework.Composition.Model;
using RI.Framework.Services;
using RI.Framework.Services.Modularization;


[Export]
public class GameRules : MonoModule
{
}


[Export]
public class EnemyManager : MonoModule
{
    [Import]
    public CompositionContainer Container { get; set; }

    protected override void Initialize ()
    {
        base.Initialize();
        
        GameRules rules = this.Container.GetExport<GameRules>();
    }
}
          ]]>
                </code>
                <para>
                    If you want to export a type which is not under your control, so you cannot apply
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.Model.ExportAttribute</codeEntityReference>
                    to it, you can also explicitly export a type:
                </para>
                <code language="cs">
                    <![CDATA[
using RI.Framework.Composition;
using RI.Framework.Composition.Model;
using RI.Framework.Services;
using RI.Framework.Services.Modularization;


[Export]
public class EnemyManager : MonoModule
{
    [Import]
    public CompositionContainer Container { get; set; }

    protected override void Initialize ()
    {
        base.Initialize();
        
        this.Container.AddExport(typeof(SomeOtherType), typeof(SomeOtherType), false);
    }
}
          ]]>
                </code>
                <para>
                    And if you want to export an already created instance instead of a type (e.g. when constructing the object is complex), you can also explicitly export an instance of a type:
                </para>
                <code language="cs">
                    <![CDATA[
using RI.Framework.Composition;
using RI.Framework.Composition.Model;
using RI.Framework.Services;
using RI.Framework.Services.Modularization;


[Export]
public class EnemyManager : MonoModule
{
    [Import]
    public CompositionContainer Container { get; set; }

    protected override void Initialize ()
    {
        base.Initialize();
        
        this.Container.AddExport(new SomeOtherType("Test", 123, SomeEnum.Default), typeof(SomeOtherType));
    }
}
          ]]>
                </code>
                <para>
                    Exporting and importing is not restricted to modules.
                    Any class type can be exported and/or have imports as long as they go through the composition container.
                </para>
                <para>
                    One special case is a type which inherits from <legacyItalic>MonoBehaviour</legacyItalic>.
                    Instances of <legacyItalic>MonoBehaviour</legacyItalic> cannot be instantiated in a normal way, they need to be added as a component to a
                    <legacyItalic>GameObject</legacyItalic>.
                    Therefore, if you want to make a <legacyItalic>MonoBehaviour</legacyItalic> discoverable, you need to inherit from
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Composition.ComposableMonoBehaviour</codeEntityReference>
                    instead of <legacyItalic>MonoBehaviour</legacyItalic>.
                    During instantiation, a new <legacyItalic>GameObject</legacyItalic> is automatically created to which the
                    <legacyItalic>MonoBehaviour</legacyItalic> is then added.
                </para>
                <para>
                    Another special case is that only modules are automatically instantiated and initialized during startup (by the bootstrapper).
                    Any other type contained in a composition container is only instantiated when an actual instance is required (importing or explicit retrieval).
                    Therefore, if a type in a composition container is never imported nor requested, no instances of that type will be created.
                </para>
                <code language="cs">
                    <![CDATA[
using RI.Framework.Composition;
using RI.Framework.Composition.Model;
using RI.Framework.Services;
using RI.Framework.Services.Modularization;


[Export]
public class Raycaster : ComposableMonoBehaviour
{
}


[Export]
public class EnemyManager : MonoModule
{
    protected override void Initialize ()
    {
        base.Initialize();
        
        Raycaster raycaster = this.Container.GetExport<Raycaster>();
    }
}
          ]]>
                </code>
                <para>
                    It is also possible to import multiple instances of a type.
                    The following example shows how to import all concrete implementations of an interface:
                </para>
                <code language="cs">
                    <![CDATA[
using RI.Framework.Composition;
using RI.Framework.Composition.Model;
using RI.Framework.Services;
using RI.Framework.Services.Modularization;


[Export]
public interface IEnemyAI
{
}


public class SmartEnemyAI : IEnemyAI
{
}


public class DumbEnemyAI : IEnemyAI
{
}


[Export]
public class EnemyManager : MonoModule
{
    // importing multiple instances is only possible with the Import proxy in order to be AOT-compatible
    // this is also why we need to explicitly specify the desired type

    [Import(typeof(IEnemyAI))]
    public Import AIs { get; set; }
  
    protected override void Initialize ()
    {
        base.Initialize();
        
        // one way is to retrieve all instances as an array
        IEnemyAI[] aiArray = this.AIs.ToArray<IEnemyAI>();
        
        // ...or a list
        List<IEnemyAI> aiList = this.AIs.ToList<IEnemyAI>();
        
        // ...or by enumerating them
        foreach(var ai in this.AIs.Values<IEnemyAI>())
        {
        }
        
        // ...or by picking the first available
        IEnemyAI first = this.AIs.Value<IEnemyAI>();
    }
}
          ]]>
                </code>
                <para>
                    And last but not least: Circular dependencies are possible.
                    For example, object A can import object B and object B can import object A.
                </para>
                <para>
                    One thing was not yet explicitly addressed: Why use modules instead of regular
                    <legacyItalic>MonoBehaviour</legacyItalic>s attached to <legacyItalic>GameObject</legacyItalic>s?
                    The three reasons are: Modules are singletons, go through the composition container (making them exportable/importable), and are automatically instantiated and initialized by the module service during bootstrapping (compared to other exported types which are only instantiated when retrieved from the composition container).
                </para>
            </content>
        </section>

        <section address="ServiceLocator">
            <title>ServiceLocator</title>
            <content>
                <para>
                    The
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.ServiceLocator</codeEntityReference>
                    lets you use the decoupling features from anywhere.
                    It provides global access to the composition container which is created by the bootstrapper.
                </para>
                <para>
                    To use the service locator, simply specify the type you need an instance of (similar to explicitly retrieving an instance from a composition container):
                </para>
                <code language="cs">
                    <![CDATA[
ServiceLocator.GetInstance<GameManager>().Win();
          ]]>
                </code>
                <para>
                    This works also for multiple instances of a type:
                </para>
                <code language="cs">
                    <![CDATA[
using RI.Framework.Composition;
using RI.Framework.Composition.Model;
using RI.Framework.Services;
using RI.Framework.Services.Modularization;


[Export]
public interface IEnemyAI
{
}


public class SmartEnemyAI : IEnemyAI
{
}


public class DumbEnemyAI : IEnemyAI
{
}


[Export]
public class EnemyManager : MonoModule
{
    public IEnemyAI[] EnemyAIs;
  
    protected override void Initialize ()
    {
        base.Initialize();
        
        this.EnemyAIs = ServiceLocator.GetInstances<IEnemyAI>();
    }
}
          ]]>
                </code>
                <para>
                    Be aware that using the service locator is considerably slower than property-based importing as shown in the previous section.
                    Property-based importing performs resolving of the instances only once (which is not fully true, as explained in
                    <link xlink:href="8ec8f13f-ef95-4aec-8fc1-9b54dff96e01" />).
                    The service locator however performs resolving each time it is used.
                </para>
            </content>
        </section>

        <section address="DispatcherService_Messaging">
            <title>DispatcherService (Messaging)</title>
            <content>
                <para>
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Dispatcher.DispatcherService</codeEntityReference>
                    is used to send and receive messages.
                    Sending and receiving messages is very simple: Any object which has access to
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Dispatcher.DispatcherService</codeEntityReference>
                    (e.g. by using property-based importing or through the service locator) can send and receive messages.
                </para>
                <para>
                    To receive a message of a specified type, a receiver needs to be registered:
                </para>
                <code language="cs">
                    <![CDATA[
using RI.Framework.Services;
using RI.Framework.Services.Dispatcher;
using RI.Framework.Services.Modularization;


public class KillEvent
{
}


public class GameRules : MonoModule
{
    [Import]
    public DispatcherService Dispatcher { get; set; }
  
    private void OnKill(KillEvent killEvent)
    {
        // process kill event
    }

    protected override void Initialize ()
    {
        base.Initialize();
        
        // register OnKill to receive all messages of type KillEvent
        this.Dispatcher.RegisterReceiver<KillEvent>(this.OnKill);
    }
}
          ]]>
                </code>
                <para>
                    A message is sent by broadcasting it to all its registered receivers:
                </para>
                <code language="cs">
                    <![CDATA[
using RI.Framework.Services;
using RI.Framework.Services.Dispatcher;
using RI.Framework.Services.Modularization;


public class KillEvent
{
}


public class EnemyManager : MonoModule
{
    [Import]
    public DispatcherService Dispatcher { get; set; }

    void Update ()
    {
        if(enemyIsKilled)
        {
            // broadcast a message of type KillEvent to all registered KillEvent receivers
            this.Dispatcher.Broadcast(new KillEvent());
        }
    }
}
          ]]>
                </code>
                <para>
                    The messaging system is type-based.
                    It means that a message of a certain type is received by each receiver which registered for that message type.
                    Any class type can be used as a message.
                </para>
                <para>
                    Messages can be sent from any thread but are delivered to the receivers in Unitys main/foreground thread.
                    This makes it a good tool for asynchronous cross-thread interaction or, for example, to deliver events and results from a background thread to the main/foreground thread.
                </para>
                <para>
                    Messages are delivered asynchronously.
                    It means that the messages are not immediately delivered to the respective receivers when sent.
                    Instead, the messages are put into a queue and are delivered from there during certain points in time of a frame cycle.
                    The only exception to this is when the priority <legacyItalic>Now</legacyItalic> is used, which will deliver the message immediately and in the thread which does the sending.
                </para>
                <para>
                    Each message has a
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Dispatcher.DispatcherPriority</codeEntityReference>
                    which defines at which point in time during a frame cycle the message is delivered.
                </para>
            </content>
        </section>

        <section address="DispatcherService_Jobs">
            <title>DispatcherService (Jobs)</title>
            <content>
                <para>
                    Besides messaging,
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Dispatcher.DispatcherService</codeEntityReference>
                    also lets you dispatch operations (or jobs).
                </para>
                <para>
                    Note that there is also
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Utilities.Threading.ThreadMover</codeEntityReference>
                    which is also a nice cross-thread execution tool when working with coroutines.
                </para>
                <para>
                    The following example shows how to dispatch a simple operation:
                </para>
                <code language="cs">
                    <![CDATA[
using RI.Framework.Services;
using RI.Framework.Services.Dispatcher;
using RI.Framework.Services.Modularization;


public class MyModule : MonoModule
{
    [Import]
    public DispatcherService Dispatcher { get; set; }

    protected override void Initialize ()
    {
        base.Initialize();
        
        this.Dispatcher.Dispatch(() => Debug.Log("I'm being logged with default priority"));
    
        this.Dispatcher.Dispatch(DispatcherPriority.Idle, () => Debug.Log("I'm being logged when the dispatcher is idle"));
    }
}
          ]]>
                </code>
                <para>
                    The following example shows how to dispatch an operation which has parameters:
                </para>
                <code language="cs">
                    <![CDATA[
using RI.Framework.Services;
using RI.Framework.Services.Dispatcher;
using RI.Framework.Services.Modularization;


public class MyModule : MonoModule
{
    [Import]
    public DispatcherService Dispatcher { get; set; }

    protected override void Initialize ()
    {
        base.Initialize();
        
        this.Dispatcher.Dispatch(x => Debug.Log(x), "I'm x !");

        this.Dispatcher.Dispatch(DispatcherPriority.Background, filename => 
        {
            LoadMeshFromFile(filename);
        }, "Spaceship.obj").OnFinished((_op, _args) => Debug.Log("Spaceship was loaded in the background."));
    }
}
          ]]>
                </code>
                <para>
                    Operations can be dispatched from any thread but are executed in Unitys main/foreground thread.
                    This makes it a good tool for asynchronous cross-thread execution or, for example, to continue a procedure from a background thread in the main/foreground thread.
                </para>
                <para>
                    Operations are executed asynchronously.
                    It means that the operations are not immediately executed when dispatched.
                    Instead, the operations are put into a queue and are executed from there during certain points in time of a frame cycle.
                    The only exception to this is when the priority <legacyItalic>Now</legacyItalic> is used, which will execute the operation immediately and in the thread which does the dispatching.
                </para>
                <para>
                    Each operation has a
                    <codeEntityReference qualifyHint="false">T:RI.Framework.Services.Dispatcher.DispatcherPriority</codeEntityReference>
                    which defines at which point in time during a frame cycle the operation is executed.
                </para>
                <para>
                    A particular use case for dispatched operations are situations where run-to-completion behaviour is required.
                    For example: A method needs an operation executed but not before the method itself has returned.
                    This is especially required for handling state transitions in state machines where you want to dispatch a state transition but the actual transition should not happen before the current method is finished (so that the rest of the method, after the dispatching of the transient, can still finish with the current state).
                </para>
            </content>
        </section>

        <relatedTopics />

    </developerConceptualDocument>
</topic>